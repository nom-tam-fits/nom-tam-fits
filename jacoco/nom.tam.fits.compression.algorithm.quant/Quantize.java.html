<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Quantize.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.fits.compression.algorithm.quant</a> &gt; <span class="el_source">Quantize.java</span></div><h1>Quantize.java</h1><pre class="source lang-java linenums">package nom.tam.fits.compression.algorithm.quant;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

import java.util.Arrays;

public class Quantize {

    class DoubleArrayPointer {

        private final double[] array;

        private int startIndex;

<span class="fc" id="L44">        DoubleArrayPointer(double[] arrayIn) {</span>
<span class="fc" id="L45">            this.array = arrayIn;</span>
<span class="fc" id="L46">        }</span>

        public DoubleArrayPointer copy(long l) {
<span class="fc" id="L49">            DoubleArrayPointer result = new DoubleArrayPointer(this.array);</span>
<span class="fc" id="L50">            result.startIndex = (int) l;</span>
<span class="fc" id="L51">            return result;</span>
        }

        public double get(int ii) {
<span class="fc" id="L55">            return this.array[ii + this.startIndex];</span>
        }
    }

    private static final double DEFAULT_QUANT_LEVEL = 4.;

    private static final double MAX_INT_AS_DOUBLE = Integer.MAX_VALUE;

    private static final int MINIMUM_PIXEL_WIDTH = 9;

    /**
     * number of reserved values, starting with
     */
    private static final long N_RESERVED_VALUES = 10;

    private static final int N4 = 4;

    private static final int N6 = 6;

    private static final double NOISE_2_MULTIPLICATOR = 1.0483579;

    private static final double NOISE_3_MULTIPLICATOR = 0.6052697;

    private static final double NOISE_5_MULTIPLICATOR = 0.1772048;

    private final QuantizeOption parameter;

    /**
     * maximum non-null value
     */
    private double maxValue;

    /**
     * minimum non-null value
     */
    private double minValue;

    /**
     * number of good, non-null pixels?
     */
    private long ngood;

    /**
     * returned 2nd order MAD of all non-null pixels
     */
    private double noise2;

    /**
     * returned 3rd order MAD of all non-null pixels
     */
    private double noise3;

    /* returned 5th order MAD of all non-null pixels */
    private double noise5;

    private double xmaxval;

    private double xminval;

    private double xnoise2;

    private double xnoise3;

    private double xnoise5;

<span class="fc" id="L120">    public Quantize(QuantizeOption quantizeOption) {</span>
<span class="fc" id="L121">        this.parameter = quantizeOption;</span>
<span class="fc" id="L122">    }</span>

    /**
     * Estimate the median and background noise in the input image using 2nd,
     * 3rd and 5th order Median Absolute Differences. The noise in the
     * background of the image is calculated using the MAD algorithms developed
     * for deriving the signal to noise ratio in spectra (see issue #42 of the
     * ST-ECF newsletter, http://www.stecf.org/documents/newsletter/) 3rd order:
     * noise = 1.482602 / sqrt(6) * median (abs(2*flux(i) - flux(i-2) -
     * flux(i+2))) The returned estimates are the median of the values that are
     * computed for each row of the image.
     * 
     * @param arrayIn
     *            2 dimensional tiledImageOperation of image pixels
     * @param nx
     *            number of pixels in each row of the image
     * @param ny
     *            number of rows in the image
     * @param nullcheck
     *            check for null values, if true
     * @param nullvalue
     *            value of null pixels, if nullcheck is true
     */
    private void calculateNoise(double[] arrayIn, int nx, int ny) {
<span class="fc" id="L146">        DoubleArrayPointer array = new DoubleArrayPointer(arrayIn);</span>
<span class="fc" id="L147">        initializeNoise();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (nx &lt; MINIMUM_PIXEL_WIDTH) {</span>
            // treat entire tiledImageOperation as an image with a single row
<span class="fc" id="L150">            nx = nx * ny;</span>
<span class="fc" id="L151">            ny = 1;</span>
        }
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (calculateNoiseShortRow(array, nx, ny)) {</span>
<span class="fc" id="L154">            return;</span>
        }
        DoubleArrayPointer rowpix;
<span class="fc" id="L157">        int nrows = 0, nrows2 = 0;</span>
<span class="fc" id="L158">        long ngoodpix = 0;</span>
        /* allocate arrays used to compute the median and noise estimates */
<span class="fc" id="L160">        double[] differences2 = new double[nx];</span>
<span class="fc" id="L161">        double[] differences3 = new double[nx];</span>
<span class="fc" id="L162">        double[] differences5 = new double[nx];</span>
<span class="fc" id="L163">        double[] diffs2 = new double[ny];</span>
<span class="fc" id="L164">        double[] diffs3 = new double[ny];</span>
<span class="fc" id="L165">        double[] diffs5 = new double[ny];</span>
        /* loop over each row of the image */
<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (int jj = 0; jj &lt; ny; jj++) {</span>
<span class="fc" id="L168">            rowpix = array.copy(jj * nx); /* point to first pixel in the row */</span>
<span class="fc" id="L169">            int ii = 0;</span>
<span class="fc" id="L170">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ii);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L172">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L174">            double v1 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L175">            ngoodpix++;</span>
<span class="fc" id="L176">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ++ii);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L178">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L180">            double v2 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L181">            ngoodpix++;</span>
<span class="fc" id="L182">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ++ii);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L184">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L186">            double v3 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L187">            ngoodpix++;</span>
<span class="fc" id="L188">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ++ii);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L190">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L192">            double v4 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L193">            ngoodpix++;</span>
<span class="fc" id="L194">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ++ii);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L196">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L198">            double v5 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L199">            ngoodpix++;</span>
<span class="fc" id="L200">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ++ii);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L202">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L204">            double v6 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L205">            ngoodpix++;</span>
<span class="fc" id="L206">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ++ii);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L208">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L210">            double v7 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L211">            ngoodpix++;</span>
<span class="fc" id="L212">            ii = findNextValidPixelWithNullCheck(nx, rowpix, ++ii);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            if (ii == nx) {</span>
<span class="fc" id="L214">                continue; /* hit end of row */</span>
            }
<span class="fc" id="L216">            double v8 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
<span class="fc" id="L217">            ngoodpix++;</span>
            // now populate the differences arrays for the remaining pixels in
            // the row */
<span class="fc" id="L220">            int nvals = 0;</span>
<span class="fc" id="L221">            int nvals2 = 0;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            for (ii++; ii &lt; nx; ii++) {</span>
<span class="fc" id="L223">                ii = findNextValidPixelWithNullCheck(nx, rowpix, ii);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">                if (ii == nx) {</span>
<span class="fc" id="L225">                    continue; /* hit end of row */</span>
                }
<span class="fc" id="L227">                double v9 = getNextPixelAndCheckMinMax(rowpix, ii);</span>
                /* construct tiledImageOperation of absolute differences */
<span class="fc bfc" id="L229" title="All 4 branches covered.">                if (!(v5 == v6 &amp;&amp; v6 == v7)) {</span>
<span class="fc" id="L230">                    differences2[nvals2] = Math.abs(v5 - v7);</span>
<span class="fc" id="L231">                    nvals2++;</span>
                }
<span class="fc bfc" id="L233" title="All 8 branches covered.">                if (!(v3 == v4 &amp;&amp; v4 == v5 &amp;&amp; v5 == v6 &amp;&amp; v6 == v7)) {</span>
<span class="fc" id="L234">                    differences3[nvals] = Math.abs(2 * v5 - v3 - v7);</span>
<span class="fc" id="L235">                    differences5[nvals] = Math.abs(N6 * v5 - N4 * v3 - N4 * v7 + v1 + v9);</span>
<span class="fc" id="L236">                    nvals++;</span>
                } else {
                    /* ignore constant background regions */
<span class="fc" id="L239">                    ngoodpix++;</span>
                }
                /* shift over 1 pixel */
<span class="fc" id="L242">                v1 = v2;</span>
<span class="fc" id="L243">                v2 = v3;</span>
<span class="fc" id="L244">                v3 = v4;</span>
<span class="fc" id="L245">                v4 = v5;</span>
<span class="fc" id="L246">                v5 = v6;</span>
<span class="fc" id="L247">                v6 = v7;</span>
<span class="fc" id="L248">                v7 = v8;</span>
<span class="fc" id="L249">                v8 = v9;</span>
            } /* end of loop over pixels in the row */
            // compute the median diffs Note that there are 8 more pixel values
            // than there are diffs values.
<span class="fc" id="L253">            ngoodpix += nvals;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (nvals == 0) {</span>
<span class="fc" id="L255">                continue; /* cannot compute medians on this row */</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            } else if (nvals == 1) {</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">                if (nvals2 == 1) {</span>
<span class="fc" id="L258">                    diffs2[nrows2] = differences2[0];</span>
<span class="fc" id="L259">                    nrows2++;</span>
                }
<span class="fc" id="L261">                diffs3[nrows] = differences3[0];</span>
<span class="fc" id="L262">                diffs5[nrows] = differences5[0];</span>
            } else {
                /* quick_select returns the median MUCH faster than using qsort */
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">                if (nvals2 &gt; 1) {</span>
<span class="fc" id="L266">                    diffs2[nrows2] = quickSelect(differences2, nvals);</span>
<span class="fc" id="L267">                    nrows2++;</span>
                }
<span class="fc" id="L269">                diffs3[nrows] = quickSelect(differences3, nvals);</span>
<span class="fc" id="L270">                diffs5[nrows] = quickSelect(differences5, nvals);</span>
            }
<span class="fc" id="L272">            nrows++;</span>
        } /* end of loop over rows */
<span class="fc" id="L274">        computeMedianOfValuesEachRow(nrows, nrows2, diffs2, diffs3, diffs5);</span>
<span class="fc" id="L275">        setNoiseResult(ngoodpix);</span>
<span class="fc" id="L276">    }</span>

    private boolean calculateNoiseShortRow(DoubleArrayPointer array, int nx, int ny) {
        /* rows must have at least 9 pixels */
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (nx &lt; MINIMUM_PIXEL_WIDTH) {</span>
<span class="fc" id="L281">            int ngoodpix = 0;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            for (int index = 0; index &lt; nx; index++) {</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                if (isNull(array.get(index))) {</span>
<span class="fc" id="L284">                    continue;</span>
                }
<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (array.get(index) &lt; this.xminval) {</span>
<span class="fc" id="L287">                    this.xminval = array.get(index);</span>
                }
<span class="fc bfc" id="L289" title="All 2 branches covered.">                if (array.get(index) &gt; this.xmaxval) {</span>
<span class="fc" id="L290">                    this.xmaxval = array.get(index);</span>
                }
<span class="fc" id="L292">                ngoodpix++;</span>
            }
<span class="fc" id="L294">            setNoiseResult(ngoodpix);</span>
<span class="fc" id="L295">            return true;</span>
        }
<span class="fc" id="L297">        return false;</span>
    }

    protected void computeMedianOfValuesEachRow(int nrows, int nrows2, double[] diffs2, double[] diffs3, double[] diffs5) {
        // compute median of the values for each row.
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (nrows == 0) {</span>
<span class="fc" id="L303">            this.xnoise3 = 0;</span>
<span class="fc" id="L304">            this.xnoise5 = 0;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        } else if (nrows == 1) {</span>
<span class="fc" id="L306">            this.xnoise3 = diffs3[0];</span>
<span class="fc" id="L307">            this.xnoise5 = diffs5[0];</span>
        } else {
<span class="fc" id="L309">            Arrays.sort(diffs3, 0, nrows);</span>
<span class="fc" id="L310">            Arrays.sort(diffs5, 0, nrows);</span>
<span class="fc" id="L311">            this.xnoise3 = (diffs3[(nrows - 1) / 2] + diffs3[nrows / 2]) / 2.;</span>
<span class="fc" id="L312">            this.xnoise5 = (diffs5[(nrows - 1) / 2] + diffs5[nrows / 2]) / 2.;</span>
        }
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (nrows2 == 0) {</span>
<span class="fc" id="L315">            this.xnoise2 = 0;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        } else if (nrows2 == 1) {</span>
<span class="fc" id="L317">            this.xnoise2 = diffs2[0];</span>
        } else {
<span class="fc" id="L319">            Arrays.sort(diffs2, 0, nrows2);</span>
<span class="fc" id="L320">            this.xnoise2 = (diffs2[(nrows2 - 1) / 2] + diffs2[nrows2 / 2]) / 2.;</span>
        }
<span class="fc" id="L322">    }</span>

    protected int findNextValidPixelWithNullCheck(int nx, DoubleArrayPointer rowpix, int ii) {
<span class="fc" id="L325">        return ii;</span>
    }

    private double getNextPixelAndCheckMinMax(DoubleArrayPointer rowpix, int ii) {
<span class="fc" id="L329">        double pixelValue = rowpix.get(ii); /* store the good pixel value */</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (pixelValue &lt; this.xminval) {</span>
<span class="fc" id="L331">            this.xminval = pixelValue;</span>
        }
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (pixelValue &gt; this.xmaxval) {</span>
<span class="fc" id="L334">            this.xmaxval = pixelValue;</span>
        }
<span class="fc" id="L336">        return pixelValue;</span>
    }

    protected double getNoise2() {
<span class="fc" id="L340">        return this.noise2;</span>
    }

    protected double getNoise3() {
<span class="fc" id="L344">        return this.noise3;</span>
    }

    protected double getNoise5() {
<span class="fc" id="L348">        return this.noise5;</span>
    }

    private void initializeNoise() {
<span class="fc" id="L352">        this.xnoise2 = 0;</span>
<span class="fc" id="L353">        this.xnoise3 = 0;</span>
<span class="fc" id="L354">        this.xnoise5 = 0;</span>
<span class="fc" id="L355">        this.xminval = Double.MAX_VALUE;</span>
<span class="fc" id="L356">        this.xmaxval = Double.MIN_VALUE;</span>
<span class="fc" id="L357">    }</span>

    protected boolean isNull(double d) {
<span class="fc" id="L360">        return false;</span>
    }

    /**
     * arguments: long row i: tile number = row number in the binary table
     * double fdata[] i: tiledImageOperation of image pixels to be compressed
     * long nxpix i: number of pixels in each row of fdata long nypix i: number
     * of rows in fdata nullcheck i: check for nullvalues in fdata? double
     * in_null_value i: value used to represent undefined pixels in fdata float
     * qlevel i: quantization level int dither_method i; which dithering method
     * to use int idata[] o: values of fdata after applying bzero and bscale
     * double bscale o: scale factor double bzero o: zero offset int iminval o:
     * minimum quantized value that is returned int imaxval o: maximum quantized
     * value that is returned The function value will be one if the input fdata
     * were copied to idata; in this case the parameters bscale and bzero can be
     * used to convert back to nearly the original floating point values: fdata
     * ~= idata * bscale + bzero. If the function value is zero, the data were
     * not copied to idata.
     * &lt;p&gt;
     * In earlier implementations of the compression code, we only used the
     * noise3 value as the most reliable estimate of the background noise in an
     * image. If it is not possible to compute a noise3 value, then this serves
     * as a red flag to indicate that quantizing the image could cause a loss of
     * significant information in the image.
     * &lt;/p&gt;
     * &lt;p&gt;
     * At some later date, we decided to take the more conservative approach of
     * using the minimum of all three of the noise values (while still requiring
     * that noise3 has a defined value) as the best estimate of the noise. Note
     * that if an image contains pure Gaussian distributed noise, then noise2,
     * noise3, and noise5 will have exactly the same value (within statistical
     * measurement errors).
     * &lt;/p&gt;
     * 
     * @param fdata
     *            the data to quantinize
     * @param nxpix
     *            the image width
     * @param nypix
     *            the image hight
     * @return true if the quantification was possible
     */
    public boolean quantize(double[] fdata, int nxpix, int nypix) {
        // MAD 2nd, 3rd, and 5th order noise values
        double stdev;
        double bScale; /* bscale, 1 in intdata = delta in fdata */

<span class="fc" id="L407">        long nx = (long) nxpix * (long) nypix;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (nx &lt;= 1L) {</span>
<span class="fc" id="L409">            this.parameter.setBScale(1.);</span>
<span class="fc" id="L410">            this.parameter.setBZero(0.);</span>
<span class="fc" id="L411">            return false;</span>
        }
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (this.parameter.getQLevel() &gt;= 0.) {</span>
            /* estimate background noise using MAD pixel differences */
<span class="fc" id="L415">            calculateNoise(fdata, nxpix, nypix);</span>
            // special case of an image filled with Nulls
<span class="fc bfc" id="L417" title="All 4 branches covered.">            if (this.parameter.isCheckNull() &amp;&amp; this.ngood == 0) {</span>
                /* set parameters to dummy values, which are not used */
<span class="fc" id="L419">                this.minValue = 0.;</span>
<span class="fc" id="L420">                this.maxValue = 1.;</span>
<span class="fc" id="L421">                stdev = 1;</span>
            } else {
                // use the minimum of noise2, noise3, and noise5 as the best
                // noise value
<span class="fc" id="L425">                stdev = this.noise3;</span>
<span class="fc bfc" id="L426" title="All 4 branches covered.">                if (this.noise2 != 0. &amp;&amp; this.noise2 &lt; stdev) {</span>
<span class="fc" id="L427">                    stdev = this.noise2;</span>
                }
<span class="fc bfc" id="L429" title="All 4 branches covered.">                if (this.noise5 != 0. &amp;&amp; this.noise5 &lt; stdev) {</span>
<span class="fc" id="L430">                    stdev = this.noise5;</span>
                }
            }
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (this.parameter.getQLevel() == 0.) {</span>
<span class="fc" id="L434">                bScale = stdev / DEFAULT_QUANT_LEVEL; /* default quantization */</span>
            } else {
<span class="fc" id="L436">                bScale = stdev / this.parameter.getQLevel();</span>
            }
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (bScale == 0.) {</span>
<span class="fc" id="L439">                return false; /* don't quantize */</span>
            }
        } else {
            /* negative value represents the absolute quantization level */
<span class="fc" id="L443">            bScale = -this.parameter.getQLevel();</span>
            /* only nned to calculate the min and max values */
<span class="fc" id="L445">            calculateNoise(fdata, nxpix, nypix);</span>
        }
        /* check that the range of quantized levels is not &gt; range of int */
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if ((this.maxValue - this.minValue) / bScale &gt; 2. * MAX_INT_AS_DOUBLE - N_RESERVED_VALUES) {</span>
<span class="nc" id="L449">            return false; /* don't quantize */</span>
        }

<span class="fc" id="L452">        this.parameter.setBScale(bScale);</span>
<span class="fc" id="L453">        this.parameter.setMinValue(this.minValue);</span>
<span class="fc" id="L454">        this.parameter.setMaxValue(this.maxValue);</span>
<span class="fc bfc" id="L455" title="All 4 branches covered.">        this.parameter.setCheckNull(this.parameter.isCheckNull() &amp;&amp; this.ngood != nx);</span>
<span class="fc" id="L456">        return true; /* yes, data have been quantized */</span>
    }

    private double quickSelect(double[] arr, int n) {
        int low, high;
        int median;
        int middle, ll, hh;

<span class="fc" id="L464">        low = 0;</span>
<span class="fc" id="L465">        high = n - 1;</span>
<span class="fc" id="L466">        median = low + high &gt;&gt;&gt; 1; // was (low + high) / 2;</span>
        for (;;) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if (high &lt;= low) {</span>
<span class="fc" id="L469">                return arr[median];</span>
            }

<span class="fc bfc" id="L472" title="All 2 branches covered.">            if (high == low + 1) { /* Two elements only */</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                if (arr[low] &gt; arr[high]) {</span>
<span class="fc" id="L474">                    swapElements(arr, low, high);</span>
                }
<span class="fc" id="L476">                return arr[median];</span>
            }

            /* Find median of low, middle and high items; swap into position low */
<span class="fc" id="L480">            middle = low + high &gt;&gt;&gt; 1; // was (low + high) / 2;</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (arr[middle] &gt; arr[high]) {</span>
<span class="fc" id="L482">                swapElements(arr, middle, high);</span>
            }
<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (arr[low] &gt; arr[high]) {</span>
<span class="fc" id="L485">                swapElements(arr, low, high);</span>
            }
<span class="fc bfc" id="L487" title="All 2 branches covered.">            if (arr[middle] &gt; arr[low]) {</span>
<span class="fc" id="L488">                swapElements(arr, middle, low);</span>
            }

            /* Swap low item (now in position middle) into position (low+1) */
<span class="fc" id="L492">            swapElements(arr, middle, low + 1);</span>

            /* Nibble from each end towards middle, swapping items when stuck */
<span class="fc" id="L495">            ll = low + 1;</span>
<span class="fc" id="L496">            hh = high;</span>
            for (;;) {
                do {
<span class="fc" id="L499">                    ll++;</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">                } while (arr[low] &gt; arr[ll]);</span>
                do {
<span class="fc" id="L502">                    hh--;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                } while (arr[hh] &gt; arr[low]);</span>

<span class="fc bfc" id="L505" title="All 2 branches covered.">                if (hh &lt; ll) {</span>
<span class="fc" id="L506">                    break;</span>
                }

<span class="fc" id="L509">                swapElements(arr, ll, hh);</span>
            }

            /* Swap middle item (in position low) back into correct position */
<span class="fc" id="L513">            swapElements(arr, low, hh);</span>

            /* Re-set active partition */
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (hh &lt;= median) {</span>
<span class="fc" id="L517">                low = ll;</span>
            }
<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (hh &gt;= median) {</span>
<span class="fc" id="L520">                high = hh - 1;</span>
            }
        }
    }

    private void setNoiseResult(long ngoodpix) {
<span class="fc" id="L526">        this.minValue = this.xminval;</span>
<span class="fc" id="L527">        this.maxValue = this.xmaxval;</span>
<span class="fc" id="L528">        this.ngood = ngoodpix;</span>
<span class="fc" id="L529">        this.noise2 = NOISE_2_MULTIPLICATOR * this.xnoise2;</span>
<span class="fc" id="L530">        this.noise3 = NOISE_3_MULTIPLICATOR * this.xnoise3;</span>
<span class="fc" id="L531">        this.noise5 = NOISE_5_MULTIPLICATOR * this.xnoise5;</span>
<span class="fc" id="L532">    }</span>

    private void swapElements(double[] array, int one, int second) {
<span class="fc" id="L535">        double value = array[one];</span>
<span class="fc" id="L536">        array[one] = array[second];</span>
<span class="fc" id="L537">        array[second] = value;</span>
<span class="fc" id="L538">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>