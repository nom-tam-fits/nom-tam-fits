<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FitsCheckSum.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.fits.utilities</a> &gt; <span class="el_source">FitsCheckSum.java</span></div><h1>FitsCheckSum.java</h1><pre class="source lang-java linenums">package nom.tam.fits.utilities;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2015 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

import static nom.tam.fits.header.Checksum.CHECKSUM;
import static nom.tam.fits.header.Checksum.DATASUM;
import static nom.tam.util.FitsIO.BYTE_1_OF_LONG_MASK;
import static nom.tam.util.FitsIO.BYTE_2_OF_LONG_MASK;
import static nom.tam.util.FitsIO.BYTE_3_OF_LONG_MASK;
import static nom.tam.util.FitsIO.BYTE_4_OF_LONG_MASK;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import nom.tam.fits.BasicHDU;
import nom.tam.fits.FitsException;
import nom.tam.fits.Header;
import nom.tam.util.AsciiFuncs;
import nom.tam.util.BufferedDataOutputStream;
import nom.tam.util.FitsIO;

public final class FitsCheckSum {

    private static final int CHECKSUM_STRING_SIZE = 16;

    /**
     * logger to log to.
     */
<span class="fc" id="L60">    private static final Logger LOG = Logger.getLogger(FitsCheckSum.class.getName());</span>

    private static final int CHECKSUM_BLOCK_SIZE = 4;

    private static final int CHECKSUM_HALF_BLOCK_SIZE = 2;

<span class="fc" id="L66">    private FitsCheckSum() {</span>
<span class="fc" id="L67">    }</span>

    /**
     * Calculate the Seaman-Pence 32-bit 1's complement checksum over the byte
     * stream. The option to start from an intermediate checksum accumulated
     * over another previous byte stream is not implemented. The implementation
     * accumulates in two 64-bit integer values the two low-order and the two
     * high-order bytes of adjacent 4-byte groups. A carry-over of bits is never
     * done within the main loop (only once at the end at reduction to a 32-bit
     * positive integer) since an overflow of a 64-bit value (signed, with
     * maximum at 2^63-1) by summation of 16-bit values could only occur after
     * adding approximately 140G short values (=2^47) (280GBytes) or more. We
     * assume for now that this routine here is never called to swallow FITS
     * files of that size or larger. by R J Mathar
     * {@link nom.tam.fits.header.Checksum#CHECKSUM}
     * 
     * @param data
     *            the byte sequence
     * @return the 32bit checksum in the range from 0 to 2^32-1
     * @since 2005-10-05
     */
    public static long checksum(final byte[] data) {
<span class="fc" id="L89">        long hi = 0;</span>
<span class="fc" id="L90">        long lo = 0;</span>
<span class="fc" id="L91">        final int len = CHECKSUM_HALF_BLOCK_SIZE * (data.length / CHECKSUM_BLOCK_SIZE);</span>
        // System.out.println(data.length + &quot; bytes&quot;) ;
<span class="fc" id="L93">        final int remain = data.length % CHECKSUM_BLOCK_SIZE;</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (remain != 0) {</span>
<span class="nc" id="L95">            throw new IllegalArgumentException(&quot;fits blocks always must be devidable by 4&quot;);</span>
        }
        /*
         * a write(2) on Sparc/PA-RISC would write the MSB first, on Linux the
         * LSB; by some kind of coincidence, we can stay with the byte order
         * known from the original C version of the algorithm.
         */
<span class="fc bfc" id="L102" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i += CHECKSUM_HALF_BLOCK_SIZE) {</span>
            /*
             * The four bytes in this block handled by a single 'i' are each
             * signed (-128 to 127) in Java and need to be masked indivdually to
             * avoid sign extension /propagation.
             */
<span class="fc" id="L108">            int offset = CHECKSUM_HALF_BLOCK_SIZE * i;</span>
<span class="fc" id="L109">            hi += data[offset++] &lt;&lt; FitsIO.BITS_OF_1_BYTE &amp; BYTE_2_OF_LONG_MASK | data[offset++] &amp; BYTE_1_OF_LONG_MASK;</span>
<span class="fc" id="L110">            lo += data[offset++] &lt;&lt; FitsIO.BITS_OF_1_BYTE &amp; BYTE_2_OF_LONG_MASK | data[offset++] &amp; BYTE_1_OF_LONG_MASK;</span>
        }

<span class="fc" id="L113">        long hicarry = hi &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
<span class="fc" id="L114">        long locarry = lo &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">        while (hicarry != 0 || locarry != 0) {</span>
<span class="fc" id="L116">            hi = (hi &amp; FitsIO.SHORT_OF_LONG_MASK) + locarry;</span>
<span class="fc" id="L117">            lo = (lo &amp; FitsIO.SHORT_OF_LONG_MASK) + hicarry;</span>
<span class="fc" id="L118">            hicarry = hi &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
<span class="fc" id="L119">            locarry = lo &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
        }
<span class="fc" id="L121">        return (hi &lt;&lt; FitsIO.BITS_OF_2_BYTES) | lo;</span>
    }

    /**
     * Encode a 32bit integer according to the Seaman-Pence proposal.
     * 
     * @see &lt;a
     *      href=&quot;http://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/general/checksum/node14.html#SECTION00035000000000000000&quot;&gt;heasarc
     *      checksum doc&lt;/a&gt;
     * @param c
     *            the checksum previously calculated
     * @param compl
     *            complement the value
     * @return the encoded string of 16 bytes.
     */
    public static String checksumEnc(final long c, final boolean compl) {
<span class="fc" id="L137">        byte[] asc = new byte[CHECKSUM_STRING_SIZE];</span>
<span class="fc" id="L138">        final int[] exclude = {</span>
            0x3a,
            0x3b,
            0x3c,
            0x3d,
            0x3e,
            0x3f,
            0x40,
            0x5b,
            0x5c,
            0x5d,
            0x5e,
            0x5f,
            0x60
        };
<span class="fc" id="L153">        final long[] mask = {</span>
            BYTE_4_OF_LONG_MASK,
            BYTE_3_OF_LONG_MASK,
            BYTE_2_OF_LONG_MASK,
            BYTE_1_OF_LONG_MASK
        };
<span class="fc" id="L159">        final int offset = 0x30; /* ASCII 0 (zero */</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        final long value = compl ? ~c : c;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        for (int i = 0; i &lt; CHECKSUM_BLOCK_SIZE; i++) {</span>
            // each byte becomes four
<span class="fc" id="L163">            final int byt = (int) ((value &amp; mask[i]) &gt;&gt;&gt; FitsIO.BITS_OF_3_BYTES - FitsIO.BITS_OF_1_BYTE * i);</span>
<span class="fc" id="L164">            final int quotient = byt / CHECKSUM_BLOCK_SIZE + offset;</span>
<span class="fc" id="L165">            final int remainder = byt % CHECKSUM_BLOCK_SIZE;</span>
<span class="fc" id="L166">            int[] ch = new int[CHECKSUM_BLOCK_SIZE];</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            for (int j = 0; j &lt; CHECKSUM_BLOCK_SIZE; j++) {</span>
<span class="fc" id="L168">                ch[j] = quotient;</span>
            }

<span class="fc" id="L171">            ch[0] += remainder;</span>
<span class="fc" id="L172">            boolean check = true;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            while (check) {</span>
                // avoid ASCII punctuation
<span class="fc" id="L175">                check = false;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                for (int element : exclude) {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                    for (int j = 0; j &lt; CHECKSUM_BLOCK_SIZE; j += CHECKSUM_HALF_BLOCK_SIZE) {</span>
<span class="fc bfc" id="L178" title="All 4 branches covered.">                        if (ch[j] == element || ch[j + 1] == element) {</span>
<span class="fc" id="L179">                            ch[j]++;</span>
<span class="fc" id="L180">                            ch[j + 1]--;</span>
<span class="fc" id="L181">                            check = true;</span>
                        }
                    }
                }
            }

<span class="fc bfc" id="L187" title="All 2 branches covered.">            for (int j = 0; j &lt; CHECKSUM_BLOCK_SIZE; j++) {</span>
                // assign the bytes
<span class="fc" id="L189">                asc[CHECKSUM_BLOCK_SIZE * j + i] = (byte) ch[j];</span>
            }
        }
        // shift the bytes 1 to the right circularly.
<span class="fc" id="L193">        String resul = AsciiFuncs.asciiString(asc, CHECKSUM_STRING_SIZE - 1, 1);</span>
<span class="fc" id="L194">        return resul.concat(AsciiFuncs.asciiString(asc, 0, CHECKSUM_STRING_SIZE - 1));</span>
    }

    /**
     * Add or update the CHECKSUM keyword. by R J Mathar
     * 
     * @param hdu
     *            the HDU to be updated.
     * @throws FitsException
     *             if the operation failed
     * @since 2005-10-05
     */
    public static void setChecksum(BasicHDU&lt;?&gt; hdu) throws FitsException {
        /*
         * the next line with the delete is needed to avoid some unexpected
         * problems with non.tam.fits.Header.checkCard() which otherwise says it
         * expected PCOUNT and found DATE.
         */
<span class="fc" id="L212">        Header hdr = hdu.getHeader();</span>
<span class="fc" id="L213">        hdr.deleteKey(CHECKSUM);</span>
        /*
         * jThis would need org.nevec.utils.DateUtils compiled before
         * org.nevec.prima.fits .... final String doneAt =
         * DateUtils.dateToISOstring(0) ; We need to save the value of the
         * comment string because this is becoming part of the checksum
         * calculated and needs to be re-inserted again - with the same string -
         * when the second/final call to addValue() is made below.
         */
<span class="fc" id="L222">        hdr.addValue(CHECKSUM, &quot;0000000000000000&quot;);</span>

        /*
         * Convert the entire sequence of 2880 byte header cards into a byte
         * tiledImageOperation. The main benefit compared to the C implementations is that we
         * do not need to worry about the particular byte order on machines
         * (Linux/VAX/MIPS vs Hp-UX, Sparc...) supposed that the correct
         * implementation is in the write() interface.
         */
<span class="fc" id="L231">        ByteArrayOutputStream hduByteImage = new ByteArrayOutputStream();</span>
<span class="fc" id="L232">        BufferedDataOutputStream bdos = new BufferedDataOutputStream(hduByteImage);</span>

        // DATASUM keyword.
<span class="fc" id="L235">        hdu.getData().write(bdos);</span>
        try {
<span class="fc" id="L237">            bdos.flush();</span>
<span class="nc" id="L238">        } catch (IOException e) {</span>
<span class="nc" id="L239">            LOG.log(Level.SEVERE, &quot;should not happen&quot;, e);</span>
<span class="fc" id="L240">        }</span>
<span class="fc" id="L241">        byte[] data = hduByteImage.toByteArray();</span>
<span class="fc" id="L242">        checksum(data);</span>
<span class="fc" id="L243">        hdu.write(new BufferedDataOutputStream(hduByteImage));</span>
<span class="fc" id="L244">        long csd = checksum(data);</span>
<span class="fc" id="L245">        hdu.getHeader().addValue(DATASUM, Long.toString(csd));</span>

        // We already have the checsum of the data. Lets compute it for
        // the header.
<span class="fc" id="L249">        hduByteImage.reset();</span>
<span class="fc" id="L250">        hdu.getHeader().write(bdos);</span>
        try {
<span class="fc" id="L252">            bdos.flush();</span>
<span class="nc" id="L253">        } catch (IOException e) {</span>
<span class="nc" id="L254">            LOG.log(Level.SEVERE, &quot;should not happen&quot;, e);</span>
<span class="fc" id="L255">        }</span>
<span class="fc" id="L256">        data = hduByteImage.toByteArray();</span>

<span class="fc" id="L258">        long csh = checksum(data);</span>

<span class="fc" id="L260">        long cshdu = csh + csd;</span>
        // If we had a carry it should go into the
        // beginning.
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        while ((cshdu &amp; FitsIO.HIGH_INTEGER_MASK) != 0) {</span>
<span class="nc" id="L264">            long cshduIntPart = cshdu &amp; FitsIO.INTEGER_MASK;</span>
<span class="nc" id="L265">            cshdu = cshduIntPart + 1;</span>
<span class="nc" id="L266">        }</span>
        /*
         * This time we do not use a deleteKey() to ensure that the keyword is
         * replaced &quot;in place&quot;. Note that the value of the checksum is actually
         * independent to a permutation of the 80-byte records within the
         * header.
         */
<span class="fc" id="L273">        hdr.addValue(CHECKSUM, checksumEnc(cshdu, true));</span>
<span class="fc" id="L274">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>