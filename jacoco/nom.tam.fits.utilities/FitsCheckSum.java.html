<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FitsCheckSum.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.fits.utilities</a> &gt; <span class="el_source">FitsCheckSum.java</span></div><h1>FitsCheckSum.java</h1><pre class="source lang-java linenums">package nom.tam.fits.utilities;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

import static nom.tam.fits.header.Checksum.CHECKSUM;
import static nom.tam.fits.header.Checksum.DATASUM;
import static nom.tam.util.FitsIO.BYTE_1_OF_LONG_MASK;
import static nom.tam.util.FitsIO.BYTE_2_OF_LONG_MASK;
import static nom.tam.util.FitsIO.BYTE_3_OF_LONG_MASK;
import static nom.tam.util.FitsIO.BYTE_4_OF_LONG_MASK;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

import nom.tam.fits.BasicHDU;
import nom.tam.fits.FitsException;
import nom.tam.fits.Header;
import nom.tam.util.AsciiFuncs;
import nom.tam.util.FitsOutputStream;
import nom.tam.util.FitsIO;

public final class FitsCheckSum {

    private static final int CHECKSUM_STRING_SIZE = 16;

    private static final int CHECKSUM_BLOCK_SIZE = 4;

    private static final int CHECKSUM_HALF_BLOCK_SIZE = 2;

    /**
     * Calculate the Seaman-Pence 32-bit 1's complement checksum over the byte
     * stream. The option to start from an intermediate checksum accumulated
     * over another previous byte stream is not implemented. The implementation
     * accumulates in two 64-bit integer values the two low-order and the two
     * high-order bytes of adjacent 4-byte groups. A carry-over of bits is never
     * done within the main loop (only once at the end at reduction to a 32-bit
     * positive integer) since an overflow of a 64-bit value (signed, with
     * maximum at 2^63-1) by summation of 16-bit values could only occur after
     * adding approximately 140G short values (=2^47) (280GBytes) or more. We
     * assume for now that this routine here is never called to swallow FITS
     * files of that size or larger. by R J Mathar
     * {@link nom.tam.fits.header.Checksum#CHECKSUM}
     *
     * @param data
     *            the byte sequence
     * @return the 32bit checksum in the range from 0 to 2^32-1
     * @since 2005-10-05
     */
    public static long checksum(final byte[] data) {
<span class="fc" id="L79">        long hi = 0;</span>
<span class="fc" id="L80">        long lo = 0;</span>
<span class="fc" id="L81">        final int len = CHECKSUM_HALF_BLOCK_SIZE * (data.length / CHECKSUM_BLOCK_SIZE);</span>
        // System.out.println(data.length + &quot; bytes&quot;) ;
<span class="fc" id="L83">        final int remain = data.length % CHECKSUM_BLOCK_SIZE;</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (remain != 0) {</span>
<span class="fc" id="L85">            throw new IllegalArgumentException(&quot;fits blocks always must be devidable by 4&quot;);</span>
        }
        /*
         * a write(2) on Sparc/PA-RISC would write the MSB first, on Linux the
         * LSB; by some kind of coincidence, we can stay with the byte order
         * known from the original C version of the algorithm.
         */
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i += CHECKSUM_HALF_BLOCK_SIZE) {</span>
            /*
             * The four bytes in this block handled by a single 'i' are each
             * signed (-128 to 127) in Java and need to be masked indivdually to
             * avoid sign extension /propagation.
             */
<span class="fc" id="L98">            int offset = CHECKSUM_HALF_BLOCK_SIZE * i;</span>
<span class="fc" id="L99">            hi += data[offset++] &lt;&lt; FitsIO.BITS_OF_1_BYTE &amp; BYTE_2_OF_LONG_MASK | data[offset++] &amp; BYTE_1_OF_LONG_MASK;</span>
<span class="fc" id="L100">            lo += data[offset++] &lt;&lt; FitsIO.BITS_OF_1_BYTE &amp; BYTE_2_OF_LONG_MASK | data[offset++] &amp; BYTE_1_OF_LONG_MASK;</span>
        }

<span class="fc" id="L103">        long hicarry = hi &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
<span class="fc" id="L104">        long locarry = lo &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">        while (hicarry != 0 || locarry != 0) {</span>
<span class="fc" id="L106">            hi = (hi &amp; FitsIO.SHORT_OF_LONG_MASK) + locarry;</span>
<span class="fc" id="L107">            lo = (lo &amp; FitsIO.SHORT_OF_LONG_MASK) + hicarry;</span>
<span class="fc" id="L108">            hicarry = hi &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
<span class="fc" id="L109">            locarry = lo &gt;&gt;&gt; FitsIO.BITS_OF_2_BYTES;</span>
        }
<span class="fc" id="L111">        return hi &lt;&lt; FitsIO.BITS_OF_2_BYTES | lo;</span>
    }

    /**
     * Encode a 32bit integer according to the Seaman-Pence proposal.
     *
     * @see &lt;a
     *      href=&quot;http://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/general/checksum/node14.html#SECTION00035000000000000000&quot;&gt;heasarc
     *      checksum doc&lt;/a&gt;
     * @param c
     *            the checksum previously calculated
     * @param compl
     *            complement the value
     * @return the encoded string of 16 bytes.
     */
    public static String checksumEnc(final long c, final boolean compl) {
<span class="fc" id="L127">        byte[] asc = new byte[CHECKSUM_STRING_SIZE];</span>
<span class="fc" id="L128">        final int[] exclude = {</span>
            0x3a,
            0x3b,
            0x3c,
            0x3d,
            0x3e,
            0x3f,
            0x40,
            0x5b,
            0x5c,
            0x5d,
            0x5e,
            0x5f,
            0x60
        };
<span class="fc" id="L143">        final long[] mask = {</span>
            BYTE_4_OF_LONG_MASK,
            BYTE_3_OF_LONG_MASK,
            BYTE_2_OF_LONG_MASK,
            BYTE_1_OF_LONG_MASK
        };
<span class="fc" id="L149">        final int offset = 0x30; /* ASCII 0 (zero */</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        final long value = compl ? ~c : c;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (int i = 0; i &lt; CHECKSUM_BLOCK_SIZE; i++) {</span>
            // each byte becomes four
<span class="fc" id="L153">            final int byt = (int) ((value &amp; mask[i]) &gt;&gt;&gt; FitsIO.BITS_OF_3_BYTES - FitsIO.BITS_OF_1_BYTE * i);</span>
<span class="fc" id="L154">            final int quotient = byt / CHECKSUM_BLOCK_SIZE + offset;</span>
<span class="fc" id="L155">            final int remainder = byt % CHECKSUM_BLOCK_SIZE;</span>
<span class="fc" id="L156">            int[] ch = new int[CHECKSUM_BLOCK_SIZE];</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            for (int j = 0; j &lt; CHECKSUM_BLOCK_SIZE; j++) {</span>
<span class="fc" id="L158">                ch[j] = quotient;</span>
            }

<span class="fc" id="L161">            ch[0] += remainder;</span>
<span class="fc" id="L162">            boolean check = true;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            while (check) {</span>
                // avoid ASCII punctuation
<span class="fc" id="L165">                check = false;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                for (int element : exclude) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                    for (int j = 0; j &lt; CHECKSUM_BLOCK_SIZE; j += CHECKSUM_HALF_BLOCK_SIZE) {</span>
<span class="fc bfc" id="L168" title="All 4 branches covered.">                        if (ch[j] == element || ch[j + 1] == element) {</span>
<span class="fc" id="L169">                            ch[j]++;</span>
<span class="fc" id="L170">                            ch[j + 1]--;</span>
<span class="fc" id="L171">                            check = true;</span>
                        }
                    }
                }
            }

<span class="fc bfc" id="L177" title="All 2 branches covered.">            for (int j = 0; j &lt; CHECKSUM_BLOCK_SIZE; j++) {</span>
                // assign the bytes
<span class="fc" id="L179">                asc[CHECKSUM_BLOCK_SIZE * j + i] = (byte) ch[j];</span>
            }
        }
        // shift the bytes 1 to the right circularly.
<span class="fc" id="L183">        String resul = AsciiFuncs.asciiString(asc, CHECKSUM_STRING_SIZE - 1, 1);</span>
<span class="fc" id="L184">        return resul.concat(AsciiFuncs.asciiString(asc, 0, CHECKSUM_STRING_SIZE - 1));</span>
    }

    /**
     * Add or update the CHECKSUM keyword. by R J Mathar
     *
     * @param hdu
     *            the HDU to be updated.
     * @throws FitsException
     *             if the operation failed
     * @since 2005-10-05
     */
    public static void setChecksum(BasicHDU&lt;?&gt; hdu) throws FitsException {
        try {
            /*
             * the next line with the delete is needed to avoid some unexpected
             * problems with non.tam.fits.Header.checkCard() which otherwise
             * says it expected PCOUNT and found DATE.
             */
<span class="fc" id="L203">            Header hdr = hdu.getHeader();</span>
<span class="fc" id="L204">            hdr.deleteKey(CHECKSUM);</span>
<span class="fc" id="L205">            hdr.deleteKey(DATASUM);</span>
            /*
             * delete the keys to force rewriting of the ckecksum and update of
             * the checksum comment
             */
<span class="fc" id="L210">            hdr.addValue(CHECKSUM, &quot;0000000000000000&quot;);</span>
<span class="fc" id="L211">            hdr.addValue(DATASUM, &quot;0&quot;);</span>

            // write the header to stream to get the cards sorted. no need to
            // flush because we will ignore the data.
<span class="fc" id="L215">            ByteArrayOutputStream hduByteImage = new ByteArrayOutputStream();</span>
<span class="fc" id="L216">            hdu.getHeader().write(new FitsOutputStream(hduByteImage));</span>
<span class="fc" id="L217">            hduByteImage.reset();</span>

            /*
             * Convert the entire sequence of 2880 byte header cards into a byte
             * tiledImageOperation. The main benefit compared to the C
             * implementations is that we do not need to worry about the
             * particular byte order on machines (Linux/VAX/MIPS vs Hp-UX,
             * Sparc...) supposed that the correct implementation is in the
             * write() interface.
             */
<span class="fc" id="L227">            FitsOutputStream bdos = new FitsOutputStream(hduByteImage);</span>
<span class="fc" id="L228">            hdu.getData().write(bdos);</span>
<span class="fc" id="L229">            bdos.flush();</span>
            
<span class="fc" id="L231">            long csd = checksum(hduByteImage.toByteArray());</span>
<span class="fc" id="L232">            hdu.getHeader().card(DATASUM).value(Long.toString(csd));</span>

            // We already have the checksum of the data. Lets compute it for
            // the header.
<span class="fc" id="L236">            hduByteImage.reset();</span>
<span class="fc" id="L237">            hdu.getHeader().write(bdos);</span>
<span class="fc" id="L238">            bdos.flush();</span>
            
<span class="fc" id="L240">            long csh = checksum(hduByteImage.toByteArray());</span>
            
<span class="fc" id="L242">            long cshdu = csh + csd;</span>
            // If we had a carry it should go into the
            // beginning.
<span class="fc bfc" id="L245" title="All 2 branches covered.">            while ((cshdu &amp; FitsIO.HIGH_INTEGER_MASK) != 0) {</span>
<span class="fc" id="L246">                long cshduIntPart = cshdu &amp; FitsIO.INTEGER_MASK;</span>
<span class="fc" id="L247">                cshdu = cshduIntPart + 1;</span>
<span class="fc" id="L248">            }</span>
            /*
             * This time we do not use a deleteKey() to ensure that the keyword
             * is replaced &quot;in place&quot;. Note that the value of the checksum is
             * actually independent to a permutation of the 80-byte records
             * within the header.
             */
<span class="fc" id="L255">            hdr.card(CHECKSUM).value(checksumEnc(cshdu, true));</span>
<span class="fc" id="L256">        } catch (IOException e) {</span>
<span class="fc" id="L257">            throw new FitsException(&quot;Could not calculate the checksum!&quot;, e);</span>
<span class="fc" id="L258">        }</span>
<span class="fc" id="L259">    }</span>

    private FitsCheckSum() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>