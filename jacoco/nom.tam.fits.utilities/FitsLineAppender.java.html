<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FitsLineAppender.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.fits.utilities</a> &gt; <span class="el_source">FitsLineAppender.java</span></div><h1>FitsLineAppender.java</h1><pre class="source lang-java linenums">package nom.tam.fits.utilities;

import nom.tam.fits.HeaderCard;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

/**
 * This class handles the writing of a card line. It keeps track of the position
 * in the line and will limit it to 80 characters. A write will never cross the
 * line border but a write when the line is at position 80 will start a new
 * line.
 * 
 * @author Richard van Nieuwenhoven
 * 
 * @deprecated Was needed by {@link FitsLineAppender} only, which itself is deprecated in
 *              favor of the package-level &lt;code&gt;nom.tam.fits.HeaderCardFormatter&lt;/code&gt;.
 */
@Deprecated
public class FitsLineAppender {

    /**
     * A String of 80 spaces to fill up fits card space.
     */
<span class="fc" id="L53">    private static final String FULL_CARD_AS_SPACES = String.format(&quot;%80s&quot;, &quot;&quot;);</span>

    /**
     * the underlying StringBuilder to which the writing of fits lines happens.
     */
    private final StringBuilder buffer;

    /**
     * the char current position in the line.
     */
    private int charCount;

    /**
     * create a new FitsLineAppender that will have space allocated for one
     * line.
     */
<span class="fc" id="L69">    public FitsLineAppender() {</span>
<span class="fc" id="L70">        this.buffer = new StringBuilder(HeaderCard.FITS_HEADER_CARD_SIZE);</span>
<span class="fc" id="L71">    }</span>

    /**
     * append a character to the fits line.
     * 
     * @param character
     *            the character to append to the line.
     */
    public void append(char character) {
<span class="fc" id="L80">        this.buffer.append(character);</span>
<span class="fc" id="L81">        this.charCount++;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Append a sub-string to this line.
     * 
     * @param stringValue
     *            the sub string to append.
     */
    public void append(FitsSubString stringValue) {
<span class="fc" id="L91">        stringValue.appendTo(this.buffer);</span>
<span class="fc" id="L92">        this.charCount += stringValue.length();</span>
<span class="fc" id="L93">    }</span>

    /**
     * append a string to the fits line, but limit the append to the line
     * length. rest of the string will be silently truncated.
     * 
     * @param string
     *            the string to append
     */
    public void append(String string) {
<span class="fc" id="L103">        this.charCount = this.charCount % HeaderCard.FITS_HEADER_CARD_SIZE;</span>
<span class="fc" id="L104">        int newLength = this.charCount + string.length();</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (newLength &gt; HeaderCard.FITS_HEADER_CARD_SIZE) {</span>
<span class="fc" id="L106">            this.buffer.append(string, 0, HeaderCard.FITS_HEADER_CARD_SIZE - this.charCount);</span>
<span class="fc" id="L107">            this.charCount = 0;</span>
        } else {
<span class="fc" id="L109">            this.charCount = newLength;</span>
<span class="fc" id="L110">            this.buffer.append(string);</span>
        }
<span class="fc" id="L112">    }</span>

    /**
     * append a string to the buffer, replacing all occurrences of a character
     * with an other.
     * 
     * @param key
     *            the string to write
     * @param toReplace
     *            the character to replace
     * @param with
     *            the character to replace the toReplace character with.
     */
    public void appendReplacing(String key, char toReplace, char with) {
<span class="fc" id="L126">        int size = key.length();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (int index = 0; index &lt; size; index++) {</span>
<span class="fc" id="L128">            char character = key.charAt(index);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            if (character == toReplace) {</span>
<span class="fc" id="L130">                this.buffer.append(with);</span>
            } else {
<span class="fc" id="L132">                this.buffer.append(character);</span>
            }
        }
<span class="fc" id="L135">        this.charCount += size;</span>
<span class="fc" id="L136">    }</span>

    /**
     * append a number of spaces to the line, limited to the line length! This
     * will only be done if the line is already started, so attention when a
     * line is still empty this method will have no effect on empty lines.
     * 
     * @param count
     *            the number of spaces to write.
     */
    public void appendSpacesTo(int count) {
<span class="fc" id="L147">        this.charCount = this.charCount % HeaderCard.FITS_HEADER_CARD_SIZE;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (this.charCount != 0) {</span>
<span class="fc" id="L149">            int spaces = count - this.charCount;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (spaces &gt; 0) {</span>
<span class="fc" id="L151">                this.buffer.append(FitsLineAppender.FULL_CARD_AS_SPACES, 0, spaces);</span>
<span class="fc" id="L152">                this.charCount += spaces;</span>
            }
        }
<span class="fc" id="L155">    }</span>

    /**
     * fill the rest of current line with spaces and start a new fits line.
     */
    public void completeLine() {
<span class="fc" id="L161">        int count = HeaderCard.FITS_HEADER_CARD_SIZE - this.charCount % HeaderCard.FITS_HEADER_CARD_SIZE;</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (count &lt; HeaderCard.FITS_HEADER_CARD_SIZE) {</span>
<span class="fc" id="L163">            this.buffer.append(FitsLineAppender.FULL_CARD_AS_SPACES, 0, count);</span>
        }
        // line completed start with 0;
<span class="fc" id="L166">        this.charCount = 0;</span>
<span class="fc" id="L167">    }</span>

    /**
     * @return the character position in the current line.
     */
    public int length() {
<span class="fc" id="L173">        this.charCount = this.charCount % HeaderCard.FITS_HEADER_CARD_SIZE;</span>
<span class="fc" id="L174">        return this.charCount;</span>
    }

    /**
     * @return the number of characters still available in the current fits
     *         line.
     */
    public int spaceLeftInLine() {
<span class="fc" id="L182">        this.charCount = this.charCount % HeaderCard.FITS_HEADER_CARD_SIZE;</span>
<span class="fc" id="L183">        return HeaderCard.FITS_HEADER_CARD_SIZE - this.charCount;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L188">        return this.buffer.toString();</span>
    }

    public void append(String key, int start, int end) {
<span class="fc" id="L192">        this.buffer.append(key, start, end);</span>
<span class="fc" id="L193">        this.charCount += end - start;</span>
<span class="fc" id="L194">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>