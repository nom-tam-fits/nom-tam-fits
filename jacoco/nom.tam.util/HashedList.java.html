<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HashedList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.util</a> &gt; <span class="el_source">HashedList.java</span></div><h1>HashedList.java</h1><pre class="source lang-java linenums">package nom.tam.util;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 2004 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

/**
 * This class implements a structure which can
 * be accessed either through a hash or
 * as linear list. Only some elements may have
 * a hash key.
 *
 * This class is motivated by the FITS header
 * structure where a user may wish to go through
 * the header element by element, or jump directly
 * to a given keyword. It assumes that all
 * keys are unique. However, all elements in the
 * structure need not have a key.
 *
 * This class does only the search structure
 * and knows nothing of the semantics of the
 * referenced objects.
 *
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * a ordered hash map implementation.
 *
 * @param &lt;VALUE&gt;
 *            value of the map
 */
<span class="fc" id="L66">public class HashedList&lt;VALUE extends CursorValue&lt;String&gt;&gt; implements Collection&lt;VALUE&gt; {</span>

    private static final class EntryComparator&lt;VALUE extends CursorValue&lt;String&gt;&gt; implements Comparator&lt;VALUE&gt; {

        private final Comparator&lt;String&gt; comp;

<span class="fc" id="L72">        private EntryComparator(Comparator&lt;String&gt; comp) {</span>
<span class="fc" id="L73">            this.comp = comp;</span>
<span class="fc" id="L74">        }</span>

        @Override
        public int compare(VALUE o1, VALUE o2) {
<span class="fc" id="L78">            return this.comp.compare(o1.getKey(), o2.getKey());</span>
        }
    }

    private class HashedListIterator implements Cursor&lt;String, VALUE&gt; {

        /**
         * This index points to the value that would be returned in the next
         * 'next' call.
         */
        private int current;

<span class="fc" id="L90">        HashedListIterator(int start) {</span>
<span class="fc" id="L91">            this.current = start;</span>
<span class="fc" id="L92">        }</span>

        @Override
        public void add(String key, VALUE ref) {
<span class="fc" id="L96">            add(ref);</span>
<span class="fc" id="L97">        }</span>

        @Override
        public void add(VALUE reference) {
<span class="fc" id="L101">            HashedList.this.add(this.current, reference);</span>
<span class="fc" id="L102">            this.current++;</span>
                
            // AK: Do not allow the iterator to exceed the header size
            //     prev() requires this to work properly...
<span class="fc bfc" id="L106" title="All 2 branches covered.">            if (this.current &gt; HashedList.this.size()) {</span>
<span class="fc" id="L107">                this.current = HashedList.this.size();</span>
            }
<span class="fc" id="L109">        }</span>

        @Override
        public VALUE end() {
<span class="fc" id="L113">            this.current = Math.max(0, HashedList.this.ordered.size() - 1);</span>
<span class="fc" id="L114">            return next();</span>
        }

        @Override
        public boolean hasNext() {
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">            return this.current &gt;= 0 &amp;&amp; this.current &lt; HashedList.this.ordered.size();</span>
        }

        @Override
        public boolean hasPrev() {
<span class="fc bfc" id="L124" title="All 2 branches covered.">            return this.current &gt; 0;</span>
        }

        @Override
        public VALUE next() {
<span class="pc bpc" id="L129" title="1 of 4 branches missed.">            if (this.current &lt; 0 || this.current &gt;= HashedList.this.ordered.size()) {</span>
<span class="fc" id="L130">                throw new NoSuchElementException(&quot;Outside list&quot;);</span>
            }
<span class="fc" id="L132">            VALUE entry = HashedList.this.ordered.get(this.current);</span>
<span class="fc" id="L133">            this.current++;</span>
<span class="fc" id="L134">            return entry;</span>
        }

        @Override
        public VALUE next(int count) {
<span class="fc bfc" id="L139" title="All 2 branches covered.">            for (int index = 1; index &lt; count; index++) {</span>
<span class="fc" id="L140">                next();</span>
            }
<span class="fc" id="L142">            return next();</span>
        }

        @Override
        public VALUE prev() {
<span class="fc bfc" id="L147" title="All 2 branches covered.">            if (this.current &lt;= 0) {</span>
<span class="fc" id="L148">                throw new NoSuchElementException(&quot;Before beginning of list&quot;);</span>
            }
<span class="fc" id="L150">            return HashedList.this.ordered.get(--this.current);</span>
        }

        @Override
        public void remove() {
<span class="pc bpc" id="L155" title="2 of 4 branches missed.">            if (this.current &gt; 0 &amp;&amp; this.current &lt;= HashedList.this.ordered.size()) {</span>
<span class="fc" id="L156">                HashedList.this.remove(--this.current);</span>
            }
<span class="fc" id="L158">        }</span>

        @Override
        public void setKey(String key) {
<span class="fc" id="L162">            VALUE entry = HashedList.this.keyed.get(key);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (entry != null) {</span>
<span class="fc" id="L164">                this.current = indexOf(entry);</span>
            } else {
<span class="fc" id="L166">                this.current = HashedList.this.ordered.size();</span>
            }
<span class="fc" id="L168">        }</span>
    }

    /** An ordered list of the keys */
<span class="fc" id="L172">    private final ArrayList&lt;VALUE&gt; ordered = new ArrayList&lt;&gt;();</span>

    /** The key value pairs */
<span class="fc" id="L175">    private final HashMap&lt;String, VALUE&gt; keyed = new HashMap&lt;&gt;();</span>
    
    /**
     * This maintains a 'current' position in the list...
     */
<span class="fc" id="L180">    private HashedListIterator cursor = new HashedListIterator(0);</span>


    /**
     * Add an element to the list at a specified position. If that element was
     * already in the list, it is first removed from the list then added again
     * - if it was removed from a position before the position where it was to
     * be added, that position is decremented by one.
     *
     * @param pos
     *            The position at which the specified element is to be added.
     *            If pos is bigger than the size of the list the element is
     *            put at the end of the list.
     * @param reference
     *            The element to add to the list.
     *            
     */
    private void add(int pos, VALUE entry) {     
<span class="fc" id="L198">        String key = entry.getKey();</span>
<span class="fc bfc" id="L199" title="All 4 branches covered.">        if (this.keyed.containsKey(key) &amp;&amp; !unkeyedKey(key)) {</span>
<span class="fc" id="L200">            int oldPos = indexOf(entry);</span>
<span class="fc" id="L201">            internalRemove(oldPos, entry);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            if (oldPos &lt; pos) {</span>
<span class="fc" id="L203">                pos--;</span>
            }
        }
<span class="fc" id="L206">        this.keyed.put(key, entry);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (pos &gt;= this.ordered.size()) {</span>
            // AK: We are adding a card to the end of the header.
            //     If the cursor points to the end of the header, we want to increment it.
            //     We can do this by faking 'insertion' before the last position.
            //     The cursor will then advance at the end of this method.
            //     Note, that if the addition of the card was done through the cursor itself
            //     then the cursor will be incremented twice, once here, and once by the
            //     cursor itself by the HashedListIterator.add(call).
            //     But, this is fine, since the end position is properly checked by 
            //     HashedListIterator.add().
<span class="fc" id="L217">            pos = this.ordered.size() - 1;</span>
<span class="fc" id="L218">            this.ordered.add(entry);</span>
        } else {
<span class="fc" id="L220">            this.ordered.add(pos, entry);</span>
        }
        
        // AK: When inserting keys before the current position, increment the current
        //     position so it keeps pointing to the same location in the header...
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (pos &lt; cursor.current) {</span>
<span class="fc" id="L226">            cursor.current++;</span>
        }
<span class="fc" id="L228">    }</span>

    private static boolean unkeyedKey(String key) {
<span class="fc bfc" id="L231" title="All 6 branches covered.">        return &quot;COMMENT&quot;.equals(key) || &quot;HISTORY&quot;.equals(key) || key.trim().isEmpty();</span>
    }

    @Override
    public boolean add(VALUE e) {
<span class="fc" id="L236">        add(this.ordered.size(), e);</span>
<span class="fc" id="L237">        return true;</span>
    }

    /**
     * Similar to add(VALUE), except this replaces an existing card that matches the specified key in-situ.
     * At the same time, new entries are added at the current position.
     * 
     * @param key
     *            The key of the existing card (if any) to be replaced).
     * 
     * @param entry
     *            The element to add to the list.
     */
    public void update(String key, VALUE entry) {
<span class="pc bpc" id="L251" title="1 of 4 branches missed.">        if (this.keyed.containsKey(key) &amp;&amp; !unkeyedKey(key)) {</span>
<span class="fc" id="L252">            int index = indexOf(get(key));</span>
<span class="fc" id="L253">            remove(index);</span>
<span class="fc" id="L254">            add(index, entry);</span>
<span class="fc" id="L255">        } else {</span>
<span class="fc" id="L256">            cursor.add(entry);</span>
        }
<span class="fc" id="L258">    }</span>
    
    @Override
    public boolean addAll(Collection&lt;? extends VALUE&gt; c) {
<span class="fc bfc" id="L262" title="All 2 branches covered.">        for (VALUE element : c) {</span>
<span class="fc" id="L263">            add(element);</span>
<span class="fc" id="L264">        }</span>
<span class="fc" id="L265">        return true;</span>
    }

    @Override
    public void clear() {
<span class="fc" id="L270">        this.keyed.clear();</span>
<span class="fc" id="L271">        this.ordered.clear();</span>
<span class="fc" id="L272">    }</span>

    @Override
    public boolean contains(Object o) {
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (VALUE entry : this.ordered) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (o.equals(entry)) {</span>
<span class="fc" id="L278">                return true;</span>
            }
<span class="fc" id="L280">        }</span>
<span class="fc" id="L281">        return false;</span>
    }

    @Override
    public boolean containsAll(Collection&lt;?&gt; c) {
<span class="fc" id="L286">        List&lt;?&gt; values = new ArrayList&lt;Object&gt;(c);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (VALUE entry : this.ordered) {</span>
<span class="fc" id="L288">            values.remove(entry);</span>
<span class="fc" id="L289">        }</span>
<span class="fc" id="L290">        return values.isEmpty();</span>
    }

    /**
     * @return &lt;code&gt;true&lt;/code&gt; if the key is included in the list.
     * @param key
     *            the key to search
     */
    public boolean containsKey(Object key) {
<span class="fc" id="L299">        return this.keyed.containsKey(key);</span>
    }

    /**
     * @return the n'th entry from the beginning.
     * @param n
     *            the index to get
     */
    public VALUE get(int n) {
<span class="fc" id="L308">        return this.ordered.get(n);</span>
    }

    /**
     * @return the value of a keyed entry. Non-keyed entries may be returned by
     *         requesting an iterator.
     * @param key
     *            the key to search for
     */
    public VALUE get(Object key) {
<span class="fc" id="L318">        return this.keyed.get(key);</span>
    }

    // Note that, if the entry is not found, a NoSuchElementException is
    // thrown instead of returning -1 (as is usual in indexOf methods) because
    // the method is used internally in situations where the entry must be
    // there.
    int indexOf(VALUE entry) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (int index = 0; index &lt; this.ordered.size(); index++) {</span>
<span class="fc" id="L327">            String searchKey = entry.getKey();</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">            if (searchKey.equals(this.ordered.get(index).getKey())) {</span>
<span class="fc" id="L329">                return index;</span>
            }
        }
<span class="fc" id="L332">        throw new NoSuchElementException(&quot;Internal error: &quot; + entry + &quot; should have been found in &quot; + ordered);</span>
    }

    @Override
    public boolean isEmpty() {
<span class="fc" id="L337">        return this.ordered.isEmpty();</span>
    }

    /**
     * @return a HashedListIterator over the entire list.
     */
    @Override
    public HashedListIterator iterator() {
<span class="fc" id="L345">        return new HashedListIterator(0);</span>
    }

    /**
     * @return an iterator starting with the n'th entry.
     * @param n
     *            the index to start the iterator
     */
    public Cursor&lt;String, VALUE&gt; iterator(int n) {
<span class="fc bfc" id="L354" title="All 4 branches covered.">        if (n &gt;= 0 &amp;&amp; n &lt;= this.ordered.size()) {</span>
<span class="fc" id="L355">            return new HashedListIterator(n);</span>
        }
<span class="fc" id="L357">        throw new NoSuchElementException(&quot;Invalid index for iterator:&quot; + n);</span>
    }
    
    
    /** Return the iterator that represents the current position in the header. This provides a connection
     *  between editing headers through Header add/append/update methods, and via Cursors, which can be
     *  used side-by-side while maintaining desired card ordering. For the reverse direction (
     *  translating iterator position to current position in the header), we can just use findCard().
     *  
     *  @return the iterator representing the current position in the header.
     *  
     */
    public Cursor&lt;String, VALUE&gt; cursor() {
<span class="fc" id="L370">        return cursor;</span>
    }

    
    /**
     * @return an iterator over the list starting with the entry with a given
     *         key.
     * @param key
     *            the key to use as a start point
     */
    public HashedListIterator iterator(String key) {
<span class="fc" id="L381">        VALUE entry = this.keyed.get(key);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc" id="L383">            return new HashedListIterator(indexOf(entry));</span>
        }
<span class="fc" id="L385">        throw new NoSuchElementException(&quot;Unknown key for iterator:&quot; + key);</span>
    }

    /**
     * Remove an object from the list giving the object index..
     * 
     * @param index
     *            the index to remove
     * @return true if the index was in range
     */
    public boolean remove(int index) {
<span class="fc bfc" id="L396" title="All 4 branches covered.">        if (index &gt;= 0 &amp;&amp; index &lt; this.ordered.size()) {</span>
<span class="fc" id="L397">            return internalRemove(index, this.ordered.get(index));</span>
        }
<span class="fc" id="L399">        return false;</span>
    }

  
    private boolean internalRemove(int index, VALUE entry) {
<span class="fc" id="L404">        this.keyed.remove(entry.getKey());</span>
<span class="fc" id="L405">        this.ordered.remove(index);</span>
        
        // AK: if removing a key before the current position, update the current position to
        //     keep pointing to the same location.
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (index &lt; cursor.current) {</span>
<span class="fc" id="L410">            cursor.current--;</span>
        }
        
<span class="fc" id="L413">        return true;</span>
    }

    @Override
    public boolean remove(Object o) {
<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (int i = 0; i &lt; this.ordered.size(); i++) {</span>
<span class="fc" id="L419">            VALUE entry = this.ordered.get(i);</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            if (o.equals(entry)) {</span>
<span class="fc" id="L421">                return internalRemove(i, entry);</span>
            }
        }
<span class="fc" id="L424">        return false;</span>
    }

    @Override
    public boolean removeAll(Collection&lt;?&gt; c) {
<span class="fc" id="L429">        boolean result = false;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        for (Object element : c.toArray()) {</span>
<span class="pc bpc" id="L431" title="3 of 4 branches missed.">            result = remove(element) || result;</span>
        }
<span class="fc" id="L433">        return result;</span>
    }

    /**
     * Remove a keyed object from the list. Unkeyed objects can be removed from
     * the list using a HashedListIterator or using the remove(Object) method.
     * 
     * @param key
     *            the key to remove
     * @return &lt;code&gt;true&lt;/code&gt; if the key was removed
     */
    public boolean removeKey(Object key) {
<span class="fc" id="L445">        VALUE entry = get(key);</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (entry != null) { </span>
<span class="fc" id="L447">            internalRemove(indexOf(entry), entry);</span>
<span class="fc" id="L448">            return true;</span>
        }
<span class="fc" id="L450">        return false;</span>
    }

    /**
     * Replace the key of a given element.
     *
     * @param oldKey
     *            The previous key. This key must be present in the hash.
     * @param newKey
     *            The new key. This key must not be present in the hash.
     * @return if the replacement was successful.
     */
    public boolean replaceKey(String oldKey, String newKey) {

<span class="fc bfc" id="L464" title="All 4 branches covered.">        if (!this.keyed.containsKey(oldKey) || this.keyed.containsKey(newKey)) {</span>
<span class="fc" id="L465">            return false;</span>
        }
<span class="fc" id="L467">        VALUE oldVal = this.keyed.get(oldKey);</span>
        // same entry in hashmap and ordered so only one change.
<span class="fc" id="L469">        this.keyed.remove(oldKey);</span>
<span class="fc" id="L470">        this.keyed.put(newKey, oldVal);</span>
<span class="fc" id="L471">        return true;</span>
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; c) {

<span class="fc" id="L477">        Iterator&lt;VALUE&gt; iter = iterator();</span>
<span class="fc" id="L478">        boolean result = false;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L480">            Object o = iter.next();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (!c.contains(o)) {</span>
<span class="fc" id="L482">                iter.remove();</span>
<span class="fc" id="L483">                result = true;</span>
            }
<span class="fc" id="L485">        }</span>
<span class="fc" id="L486">        return result;</span>
    }

    @Override
    public int size() {
<span class="fc" id="L491">        return this.ordered.size();</span>
    }

    /**
     * Sort the keys into some desired order.
     * 
     * @param comp
     *            the comparator to use for the sorting
     */
    public void sort(final Comparator&lt;String&gt; comp) {
<span class="fc" id="L501">        java.util.Collections.sort(this.ordered, new EntryComparator&lt;VALUE&gt;(comp));</span>
<span class="fc" id="L502">    }</span>

    @Override
    public Object[] toArray() {
<span class="fc" id="L506">        return ordered.toArray();</span>
    }

    @Override
    public &lt;T&gt; T[] toArray(T[] o) {
<span class="fc" id="L511">        return ordered.toArray(o);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L516">        return this.ordered.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>