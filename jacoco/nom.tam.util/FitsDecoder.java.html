<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FitsDecoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.util</a> &gt; <span class="el_source">FitsDecoder.java</span></div><h1>FitsDecoder.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

package nom.tam.util;

import java.io.EOFException;
import java.io.IOException;
import java.lang.reflect.Array;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import nom.tam.fits.FitsFactory;
import nom.tam.util.type.ElementType;

/**
 * Class for decoding FITS-formatted binary data into Java arrays.
 * 
 * @since 1.16
 * 
 * @see FitsEncoder
 * @see FitsInputStream
 * @see FitsFile
 */
public class FitsDecoder extends ArrayDecoder {

    /** The FITS byte value for the binary representation of a boolean 'true' value */
    private static final byte FITS_TRUE = (byte) 'T';

    /**
     * Instantiates a new decoder of FITS binary data to Java arrays. To be used by subclass
     * constructors only.
     */
    protected FitsDecoder() {
<span class="fc" id="L61">        super();</span>
<span class="fc" id="L62">    }</span>
    
    /**
     * Instantiates a new FITS binary data decoder for converting FITS data representations
     * into Java arrays.
     * 
     * @param i     the FITS input.
     */
    public FitsDecoder(InputReader i) {
<span class="fc" id="L71">        super(i);</span>
<span class="fc" id="L72">    }</span>

    /**
     * Decides what to do when an {@link EOFException} is encountered after having read
     * some number of bytes from the input. The default behavior is to re-throw the
     * exception only if no data at all was obtained from the input, otherwise return
     * the non-zero byte count of data that were successfully read. Subclass implementations
     * may override this method to adjust if an when {@link EOFException} is thrown
     * upon an incomplete read.
     * 
     * @param e         the exception that was thrown, or &lt;code&gt;null&lt;/code&gt;.
     * @param got       the number of elements successfully read
     * @param expected  the number of elements expected
     * @return          the number of elements successfully read (same as &lt;code&gt;got&lt;/code&gt;).
     * @throws EOFException     the rethrown exception, or a new one, as appropriate
     */
    int eofCheck(EOFException e, int got, int expected) throws EOFException {
<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (got == 0) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (e == null) {</span>
<span class="fc" id="L91">                throw new EOFException();</span>
            }
<span class="fc" id="L93">            throw e;</span>
        }
<span class="fc" id="L95">        return got;</span>
    }

    /**
     * Gets the &lt;code&gt;boolean&lt;/code&gt; equivalent for a FITS byte value representing a logical
     * value. This call does not support &lt;code&gt;null&lt;/code&gt; values, which are allowed
     * by the FITS standard, but the similar {@link #booleanObjectFor(int)} does. FITS
     * defines 'T' as true, 'F' as false, and 0 as null. However, prior versions of this
     * library have used the value 1 for true, and 0 for false. Therefore, this
     * implementation will recognise both 'T' and 1 as &lt;code&gt;true&lt;/code&gt;, and will
     * return &lt;code&gt;false&lt;/code&gt; for all other byte values.
     * 
     * @param c     The FITS byte that defines a boolean value
     * @return      &lt;code&gt;true&lt;/code&gt; if and only if the byte is the ASCII character 'T'
     *              or has the value of 1, otherwise &lt;code&gt;false&lt;/code&gt;.
     *              
     * @see #booleanObjectFor(int)
     *              
     */
    protected static final boolean booleanFor(int c) {
<span class="fc bfc" id="L115" title="All 4 branches covered.">        return c == FITS_TRUE || c == 1;</span>
    }

    /**
     * Gets the &lt;code&gt;boolean&lt;/code&gt; equivalent for a FITS byte value representing a logical
     * value. This call supports &lt;code&gt;null&lt;/code&gt; values, which are allowed
     * by the FITS standard. FITS defines 'T' as true, 'F' as false, and 0 as null. Prior 
     * versions of this library have used the value 1 for true, and 0 for false. Therefore, this
     * implementation will recognise both 'T' and 1 as &lt;code&gt;true&lt;/code&gt;, but 0 will map
     * to &lt;code&gt;null&lt;/code&gt; and everything else will return &lt;code&gt;false&lt;/code&gt;.
     * 
     * @param c     The FITS byte that defines a boolean value
     * @return      &lt;code&gt;true&lt;/code&gt; if and only if the byte is the ASCII character 'T'
     *              or has the value of 1, &lt;code&gt;null&lt;/code&gt; it the byte is 0, otherwise &lt;code&gt;false&lt;/code&gt;.
     *              
     * @see #booleanFor(int)
     *              
     */
    @SuppressFBWarnings(value = &quot;NP_BOOLEAN_RETURN_NULL&quot;, justification = &quot;null values are explicitly allowed by FITS, so we want to support them.&quot;)
    protected static final Boolean booleanObjectFor(int c) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (c == 0) {</span>
<span class="fc" id="L136">            return null;</span>
        }
<span class="fc" id="L138">        return booleanFor(c);</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next boolean value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized boolean readBoolean() throws IOException {
<span class="fc" id="L150">        return booleanFor(readByte());</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next character value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized char readChar() throws IOException {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (FitsFactory.isUseUnicodeChars()) {</span>
<span class="fc" id="L163">            return (char) readUnsignedShort();</span>
        }
<span class="fc" id="L165">        return (char) readUnsignedByte();</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next byte the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected final byte readByte() throws IOException {
<span class="fc" id="L177">        int i = read();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc" id="L179">            throw new EOFException();</span>
        }
<span class="fc" id="L181">        return (byte) i;</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next unsigned byte from the input, or -1 if there is no more bytes available.
     * @throws IOException
     *              if there was an IO error reading from the input, other than the end-of-file.
     */
    @Deprecated
    protected synchronized int readUnsignedByte() throws IOException {
<span class="fc" id="L193">        return read();</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next 16-bit integer value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected final short readShort() throws IOException {
<span class="fc" id="L205">        int i = readUnsignedShort();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc" id="L207">            throw new EOFException();</span>
        }
<span class="fc" id="L209">        return (short) i;</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next unsigned 16-bit integer value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized int readUnsignedShort() throws IOException {
<span class="fc" id="L221">        getInputBuffer().loadOne(ElementType.SHORT.size());</span>
<span class="fc" id="L222">        return getInputBuffer().getUnsignedShort();</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next 32-bit integer value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized int readInt() throws IOException {
<span class="fc" id="L234">        getInputBuffer().loadOne(ElementType.INT.size());</span>
<span class="fc" id="L235">        return getInputBuffer().getInt();</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next 64-bit integer value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized long readLong() throws IOException {
<span class="fc" id="L247">        getInputBuffer().loadOne(ElementType.LONG.size());</span>
<span class="fc" id="L248">        return getInputBuffer().getLong();</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next single-precision (32-bit) floating point value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized float readFloat() throws IOException {
<span class="fc" id="L260">        getInputBuffer().loadOne(ElementType.FLOAT.size());</span>
<span class="fc" id="L261">        return getInputBuffer().getFloat();</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next double-precision (64-bit) floating point value from the input.
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized double readDouble() throws IOException {
<span class="fc" id="L273">        getInputBuffer().loadOne(ElementType.DOUBLE.size());</span>
<span class="fc" id="L274">        return getInputBuffer().getDouble();</span>
    }

    /**
     * @deprecated Low-level reading/writing should be handled internally as arrays by this library only.
     * 
     * @return the next line of 1-byte ASCII characters, terminated by a LF or EOF. 
     * @throws IOException
     *              if there was an IO error reading from the input.
     */
    @Deprecated
    protected synchronized String readAsciiLine() throws IOException {
<span class="fc" id="L286">        StringBuffer str = new StringBuffer();</span>
<span class="fc" id="L287">        int c = 0;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">        while ((c = read()) &gt; 0) {</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (c == '\n') {</span>
<span class="fc" id="L290">                break;</span>
            }
<span class="fc" id="L292">            str.append((char) c);</span>
        }
<span class="fc" id="L294">        return new String(str);</span>
    }

    /**
     * Reads bytes to fill the supplied buffer with the requested number of bytes from the given
     * starting buffer index. If not enough bytes are avaialable in the
     * file to deliver the reqauested number of bytes the buffer, an {@link EOFException} will be thrown.
     * 
     * @param b             the buffer
     * @param off           the buffer index at which to start reading data
     * @param len           the total number of bytes to read.
     * @throws IOException  if there was an IO error before the requested number of bytes could
     *                      all be read.
     */
    protected void readFully(byte[] b, int off, int len) throws IOException {
<span class="fc bfc" id="L309" title="All 2 branches covered.">        while (len &gt; 0) {       </span>
<span class="fc" id="L310">            int n = read(b, off, len);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (n &lt; 0) {</span>
<span class="fc" id="L312">                throw new EOFException();</span>
            }
<span class="fc" id="L314">            off += n;</span>
<span class="fc" id="L315">            len -= n;</span>
<span class="fc" id="L316">        } </span>
<span class="fc" id="L317">    }</span>
    
    /**
     * See {@link ArrayDataInput#read(boolean[], int, int)} for the general contract of this method.
     * In FITS, &lt;code&gt;true&lt;/code&gt; values are represented by the ASCII byte for 'T', whereas
     * &lt;code&gt;false&lt;/code&gt; is represented by the ASCII byte for 'F'.
     * 
     * @param b             an array of boolean values.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     */
    protected synchronized int read(boolean[] b, int start, int length) throws IOException {
<span class="fc" id="L333">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L334">        in.loadBytes(length, 1);</span>
<span class="fc" id="L335">        int to = length + start;</span>
<span class="fc" id="L336">        int k = start;</span>

        try {
<span class="fc bfc" id="L339" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc" id="L340">                int i = in.get();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">                if (i &lt; 0) {</span>
<span class="fc" id="L342">                    break;</span>
                }
<span class="fc" id="L344">                b[k] = booleanFor(i);</span>
            }
<span class="fc" id="L346">        } catch (EOFException e) {</span>
            // The underlying read(byte[], int, int) may throw an EOFException
            // (even though it should not), and so we should be prepared for that...
<span class="nc" id="L349">            return eofCheck(e, k - start, length);</span>
<span class="fc" id="L350">        }</span>
        
<span class="fc bfc" id="L352" title="All 2 branches covered.">        if (k != to) {</span>
<span class="fc" id="L353">            return eofCheck(null, k - start, length);</span>
        }

<span class="fc" id="L356">        return length;</span>
    }

    /**
     * See {@link ArrayDataInput#read(Boolean[], int, int)} for the general contract of this method.
     * In FITS, &lt;code&gt;true&lt;/code&gt; values are represented by the ASCII byte for 'T',
     * &lt;code&gt;false&lt;/code&gt; is represented by the ASCII byte for 'F', while &lt;code&gt;null&lt;/code&gt;
     * values are represented by the value 0.
     * 
     * @param b             an array of boolean values.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     */
    protected synchronized int read(Boolean[] b, int start, int length) throws IOException {
<span class="fc" id="L374">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L375">        in.loadBytes(length, 1);</span>
<span class="fc" id="L376">        int to = length + start;</span>
<span class="fc" id="L377">        int k = start;</span>

        try {
<span class="fc bfc" id="L380" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc" id="L381">                int i = in.get();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                if (i &lt; 0) {</span>
<span class="fc" id="L383">                    break;</span>
                }
<span class="fc" id="L385">                b[k] = booleanObjectFor(i);</span>
            }
<span class="fc" id="L387">        } catch (EOFException e) {</span>
            // The underlying read(byte[], int, int) may throw an EOFException
            // (even though it should not), and so we should be prepared for that...
<span class="nc" id="L390">            return eofCheck(e, k - start, length);</span>
<span class="fc" id="L391">        }</span>
        
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (k != to) {</span>
<span class="fc" id="L394">            return eofCheck(null, k - start, length);</span>
        }

<span class="fc" id="L397">        return length;</span>
    }

    /**
     * See {@link ArrayDataInput#read(char[], int, int)} for the general contract of this method. In
     * FITS characters are usually represented as 1-byte ASCII, not as the 2-byte Java types.
     * However, previous implementations if this library have erroneously written 2-byte
     * characters into the FITS. For compatibility both the FITS standard -1-byte ASCII
     * and the old 2-byte behaviour are supported, and can be selected via 
     * {@link FitsFactory#setUseUnicodeChars(boolean)}.
     * 
     * @param c             a character array.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     * 
     * @see FitsFactory#setUseUnicodeChars(boolean) 
     */
    protected synchronized int read(char[] c, int start, int length) throws IOException {
<span class="fc" id="L419">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L420">        in.loadBytes(length, ElementType.CHAR.size());</span>
<span class="fc" id="L421">        int to = length + start;</span>
<span class="fc" id="L422">        int k = start;</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">        final boolean isUnicode = ElementType.CHAR.size() != 1;</span>

        try {
<span class="fc bfc" id="L427" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                int i = isUnicode ? in.getUnsignedShort() : in.get();</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                if (i &lt; 0) {</span>
<span class="fc" id="L430">                    break;</span>
                }
<span class="fc" id="L432">                c[k] = (char) i;</span>
            }
<span class="fc" id="L434">        } catch (EOFException e) {</span>
            // The underlying read(byte[], int, int) may throw an EOFException
            // (even though it should not), and so we should be prepared for that...
<span class="nc" id="L437">            return eofCheck(e, (k - start), length) * ElementType.CHAR.size();</span>
<span class="fc" id="L438">        }</span>

<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (k != to) {</span>
<span class="fc" id="L441">            return eofCheck(null, k - start, length) * ElementType.CHAR.size();</span>
        }

<span class="fc" id="L444">        return length * ElementType.CHAR.size();</span>
    }

    /**
     * See {@link ArrayDataInput#read(short[], int, int)} for a contract of this method.
     * 
     * @param s             an array of 16-bit integer values.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     */
    protected synchronized int read(short[] s, int start, int length) throws IOException {
<span class="fc" id="L459">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L460">        in.loadBytes(length, ElementType.SHORT.size());</span>
<span class="fc" id="L461">        int to = length + start;</span>
<span class="fc" id="L462">        int k = start;</span>

        try {
<span class="fc bfc" id="L465" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc" id="L466">                int i = in.getUnsignedShort();</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">                if (i &lt; 0) {</span>
<span class="fc" id="L468">                    break;</span>
                }
<span class="fc" id="L470">                s[k] = (short) i;</span>
            }
<span class="fc" id="L472">        } catch (EOFException e) {</span>
            // The underlying read(byte[], int, int) may throw an EOFException
            // (even though it should not), and so we should be prepared for that...
<span class="nc" id="L475">            return eofCheck(e, k - start, length) * ElementType.SHORT.size();</span>
<span class="fc" id="L476">        }</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (k != to) {</span>
<span class="fc" id="L479">            return eofCheck(null, k - start, length) * ElementType.SHORT.size();</span>
        }

<span class="fc" id="L482">        return length * ElementType.SHORT.size();</span>
    }

    /**
     * See {@link ArrayDataInput#read(int[], int, int)} for a contract of this method.
     * 
     * @param j             an array of 32-bit integer values.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     */
    protected synchronized int read(int[] j, int start, int length) throws IOException {
<span class="fc" id="L497">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L498">        in.loadBytes(length, ElementType.INT.size());</span>
<span class="fc" id="L499">        int to = length + start;</span>
<span class="fc" id="L500">        int k = start;</span>

        try {
<span class="fc bfc" id="L503" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc" id="L504">                j[k] = in.getInt();</span>
            }
<span class="fc" id="L506">        } catch (EOFException e) {</span>
<span class="fc" id="L507">            return eofCheck(e, k - start, length) * ElementType.INT.size();</span>
<span class="fc" id="L508">        }</span>
<span class="fc" id="L509">        return length * ElementType.INT.size();</span>
    }

    /**
     * See {@link ArrayDataInput#read(long[], int, int)} for a contract of this method.
     * 
     * @param l             an array of 64-bit integer values.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     * 
     */
    protected synchronized int read(long[] l, int start, int length) throws IOException {
<span class="fc" id="L525">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L526">        in.loadBytes(length, ElementType.LONG.size());</span>
<span class="fc" id="L527">        int to = length + start;</span>
<span class="fc" id="L528">        int k = start;</span>

        try {
<span class="fc bfc" id="L531" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc" id="L532">                l[k] = in.getLong();</span>
            }
<span class="fc" id="L534">        } catch (EOFException e) {</span>
<span class="fc" id="L535">            return eofCheck(e, k - start, length) * ElementType.LONG.size();</span>
<span class="fc" id="L536">        }</span>
<span class="fc" id="L537">        return length * ElementType.LONG.size();</span>
    }

    /**
     * See {@link ArrayDataInput#read(float[], int, int)} for a contract of this method.
     * 
     * @param f             an array of single-precision (32-bit) floating point values.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     */
    protected synchronized int read(float[] f, int start, int length) throws IOException {
<span class="fc" id="L552">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L553">        in.loadBytes(length, ElementType.FLOAT.size());</span>
<span class="fc" id="L554">        int to = length + start;</span>
<span class="fc" id="L555">        int k = start;</span>

        try {
<span class="fc bfc" id="L558" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc" id="L559">                f[k] = in.getFloat();</span>
            }
<span class="fc" id="L561">        } catch (EOFException e) {</span>
<span class="fc" id="L562">            return eofCheck(e, k - start, length) * ElementType.FLOAT.size();</span>
<span class="fc" id="L563">        }</span>
<span class="fc" id="L564">        return length * ElementType.FLOAT.size();</span>
    }

    /**
     * See {@link ArrayDataInput#read(double[], int, int)} for a contract of this method.
     * 
     * @param d             an array of double-precision (64-bit) floating point values.
     * @param start         the buffer index at which to start reading data
     * @param length        the total number of elements to read.
     * @return the number of bytes successfully read.
     * 
     * @throws IOException  if there was an IO error before, before requested number of bytes could
     *                      be read, or an &lt;code&gt;EOFException&lt;/code&gt; if already at the end of file.
     */
    protected synchronized int read(double[] d, int start, int length) throws IOException {
<span class="fc" id="L579">        InputBuffer in = getInputBuffer();</span>
<span class="fc" id="L580">        in.loadBytes(length, ElementType.DOUBLE.size());</span>
<span class="fc" id="L581">        int to = length + start;</span>
<span class="fc" id="L582">        int k = start;</span>

        try {
<span class="fc bfc" id="L585" title="All 2 branches covered.">            for (; k &lt; to; k++) {</span>
<span class="fc" id="L586">                d[k] = in.getDouble();</span>
            }
<span class="fc" id="L588">        } catch (EOFException e) {</span>
<span class="fc" id="L589">            return eofCheck(e, k - start, length) * ElementType.DOUBLE.size();</span>
<span class="fc" id="L590">        }</span>
<span class="fc" id="L591">        return length * ElementType.DOUBLE.size();</span>
    }

    @Override
    public synchronized long readArray(Object o) throws IOException, IllegalArgumentException {
<span class="fc bfc" id="L596" title="All 2 branches covered.">        if (o == null) {</span>
<span class="fc" id="L597">            return 0L;</span>
        }
<span class="fc bfc" id="L599" title="All 2 branches covered.">        if (!o.getClass().isArray()) {</span>
<span class="fc" id="L600">            throw new IllegalArgumentException(&quot;Not an array: &quot; + o.getClass().getName());</span>
        }

<span class="fc" id="L603">        int length = Array.getLength(o);</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (length == 0) {</span>
<span class="fc" id="L605">            return 0L;</span>
        }

        // This is a 1-d array. Process it using our special
        // functions.
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (o instanceof byte[]) {</span>
<span class="fc" id="L611">            readFully((byte[]) o, 0, length);</span>
<span class="fc" id="L612">            return length;</span>
        }
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (o instanceof boolean[]) {</span>
<span class="fc" id="L615">            return read((boolean[]) o, 0, length);</span>
        }
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (o instanceof char[]) {</span>
<span class="fc" id="L618">            return read((char[]) o, 0, length);</span>
        }
<span class="fc bfc" id="L620" title="All 2 branches covered.">        if (o instanceof short[]) {</span>
<span class="fc" id="L621">            return read((short[]) o, 0, length);</span>
        }
<span class="fc bfc" id="L623" title="All 2 branches covered.">        if (o instanceof int[]) {</span>
<span class="fc" id="L624">            return read((int[]) o, 0, length);</span>
        }
<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (o instanceof float[]) {</span>
<span class="fc" id="L627">            return read((float[]) o, 0, length);</span>
        }
<span class="fc bfc" id="L629" title="All 2 branches covered.">        if (o instanceof long[]) {</span>
<span class="fc" id="L630">            return read((long[]) o, 0, length);</span>
        }
<span class="fc bfc" id="L632" title="All 2 branches covered.">        if (o instanceof double[]) {</span>
<span class="fc" id="L633">            return read((double[]) o, 0, length);</span>
        }


<span class="fc bfc" id="L637" title="All 2 branches covered.">        if (o instanceof Boolean[]) {</span>
<span class="fc" id="L638">            return read((Boolean[]) o, 0, length);</span>
        }

<span class="fc" id="L641">        Object[] array = (Object[]) o;</span>
<span class="fc" id="L642">        long count = 0L;</span>

        // Process multidim arrays recursively.
<span class="fc bfc" id="L645" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
            try {
<span class="fc" id="L647">                count += readArray(array[i]);</span>
<span class="fc" id="L648">            } catch (EOFException e) {</span>
<span class="fc" id="L649">                return count;</span>
<span class="fc" id="L650">            }  </span>
        }
<span class="fc" id="L652">        return count;</span>
    }

   
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>