<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FitsFile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.util</a> &gt; <span class="el_source">FitsFile.java</span></div><h1>FitsFile.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 2004 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

package nom.tam.util;

import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 * This class is intended for high performance reading and writing
 * FITS files or block of FITS-formatted data. It provides buffered
 * random access and efficient handling of arrays. Primitive arrays
 * may be written using a single method call. Large buffers
 * are used to minimize synchronization overheads since methods
 * of this class are not synchronized.
 * &lt;p&gt;
 * Note that although this class supports most of the contract of
 * RandomAccessFile it does not (and can not) extend that class since many of
 * the methods of RandomAccessFile are final. In practice this method works much
 * like the StreamFilter classes. All methods are implemented in this class but
 * some are simply delegated to an underlying RandomAccessFile member.
 * &lt;p&gt;
 * Testing and timing routines are available in the
 * nom.tam.util.test.BufferedFileTester class.
 *
 * &lt;p&gt;
 * Prior versions of this class under the old &lt;code&gt;BufferedFile&lt;/code&gt;
 * name:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Version 1.1 -- October 12, 2000: Fixed handling of EOF in array reads so that a
 * partial array will be returned when an EOF is detected. Excess bytes that
 * cannot be used to construct array elements will be discarded (e.g., if there
 * are 2 bytes left and the user is reading an int array).&lt;/li&gt;
 * 
 * &lt;li&gt;
 * Version 1.2 -- December 8, 2002: Added getChannel method.&lt;/li&gt;
 * 
 * &lt;li&gt;
 * Version 1.3 -- March 2, 2007: Added File based constructors.&lt;/li&gt;
 * 
 * &lt;li&gt;
 * Version 1.4 -- July 20, 2009: Added support for &amp;gt;2G Object reads.
 * This is still a bit problematic in that we do not support primitive arrays
 * larger than 2 GB/atomsize. However except in the case of bytes this is not
 * currently a major issue.&lt;/li&gt;
 * 
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * Version 2.0 -- Oct 30, 2021: New hierarchy for more digestible code. Improved
 * buffering, and renamed from &lt;code&gt;BufferedFile&lt;/code&gt; to the more appropriate 
 * name of &lt;code&gt;FitsFile&lt;/code&gt;. Performance is 2-4 times better than before.
 * 
 * @see FitsInputStream
 * @see FitsOutputStream
 * 
 * @since 1.16
 */
@SuppressWarnings(&quot;deprecation&quot;)
public class FitsFile extends ArrayDataFile implements RandomAccess, ArrayDataOutput {

<span class="fc" id="L95">    private static final Logger LOG = Logger.getLogger(FitsFile.class.getName());</span>
    
    /**
     * marker position
     */
    private long marker;

    /**
     * Create a buffered file from a File descriptor
     * 
     * @param file
     *            the file to open.
     * @throws IOException
     *             if the file could not be opened
     */
    public FitsFile(File file) throws IOException {
<span class="fc" id="L111">        this(file, &quot;r&quot;, FitsIO.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Create a buffered file from a File descriptor
     * 
     * @param file
     *            the file to open.
     * @param mode
     *            the mode to open the file in
     * @throws IOException
     *             if the file could not be opened
     */
    public FitsFile(File file, String mode) throws IOException {
<span class="fc" id="L125">        this(file, mode, FitsIO.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L126">    }</span>

    /**
     * Create a buffered file from a file descriptor
     * 
     * @param file
     *            the file to open.
     * @param mode
     *            the mode to open the file in
     * @param bufferSize
     *            the dataBuffer.buffer size to use
     * @throws IOException
     *             if the file could not be opened
     */
    public FitsFile(File file, String mode, int bufferSize) throws IOException {
<span class="fc" id="L141">        super(file, mode, bufferSize);</span>
<span class="fc" id="L142">        setDecoder(new FitsDecoder(this));</span>
<span class="fc" id="L143">        setEncoder(new FitsEncoder(this));</span>
<span class="fc" id="L144">    }</span>

    /**
     * Create a read-only buffered file
     * 
     * @param filename
     *            the name of the file to open
     * @throws IOException
     *             if the file could not be opened
     */
    public FitsFile(String filename) throws IOException {
<span class="fc" id="L155">        this(filename, &quot;r&quot;, FitsFile.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L156">    }</span>

    /**
     * Create a buffered file with the given mode.
     * 
     * @param filename
     *            The file to be accessed.
     * @param mode
     *            A string composed of &quot;r&quot; and &quot;w&quot; for read and write access.
     * @throws IOException
     *             if the file could not be opened
     */
    public FitsFile(String filename, String mode) throws IOException {
<span class="fc" id="L169">        this(filename, mode, FitsFile.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L170">    }</span>

    /**
     * Create a buffered file with the given mode and a specified
     * dataBuffer.buffer size.
     * 
     * @param filename
     *            The file to be accessed.
     * @param mode
     *            A string composed of &quot;r&quot; and &quot;w&quot; indicating read or write
     *            access.
     * @param bufferSize
     *            The dataBuffer.buffer size to be used. This should be
     *            substantially larger than 100 bytes and defaults to 32768
     *            bytes in the other constructors.
     * @throws IOException
     *             if the file could not be opened
     */
    public FitsFile(String filename, String mode, int bufferSize) throws IOException {
<span class="fc" id="L189">        this(new File(filename), mode, bufferSize);</span>
<span class="fc" id="L190">    }</span>

    
    @Override
    public FitsEncoder getEncoder() {
<span class="fc" id="L195">        return (FitsEncoder) super.getEncoder();</span>
    }
    
    @Override
    public FitsDecoder getDecoder() {
<span class="fc" id="L200">        return (FitsDecoder) super.getDecoder();</span>
    }
  
    @Override
    public final synchronized int readUnsignedByte() throws IOException {
<span class="fc" id="L205">        return getDecoder().readUnsignedByte();</span>
    }

    @Override
    public final synchronized byte readByte() throws IOException {
<span class="fc" id="L210">        return getDecoder().readByte();</span>
    }

    @Override
    public synchronized boolean readBoolean() throws IOException {
<span class="fc" id="L215">        return getDecoder().readBoolean();</span>
    }
    
    @Override
    public synchronized char readChar() throws IOException {
<span class="fc" id="L220">        return getDecoder().readChar();</span>
    }

    @Override
    public final synchronized int readUnsignedShort() throws IOException {
<span class="fc" id="L225">        return getDecoder().readUnsignedShort();</span>
    }

    @Override
    public final synchronized short readShort() throws IOException {
<span class="fc" id="L230">        return getDecoder().readShort();</span>
    }
    
    @Override
    public final synchronized int readInt() throws IOException {
<span class="fc" id="L235">        return getDecoder().readInt(); </span>
    }
    
    @Override
    public final synchronized long readLong() throws IOException {
<span class="fc" id="L240">        return getDecoder().readLong();</span>
    }

    @Override
    public final synchronized float readFloat() throws IOException {
<span class="fc" id="L245">        return getDecoder().readFloat();</span>
    }
    
    @Override
    public final synchronized double readDouble() throws IOException {
<span class="fc" id="L250">        return getDecoder().readDouble();</span>
    }
    
    @Override
    public synchronized String readLine() throws IOException {
<span class="fc" id="L255">        return getDecoder().readAsciiLine();</span>
    }

    @Override
    public final synchronized int read(boolean[] b) throws IOException {
<span class="fc" id="L260">        return read(b, 0, b.length);</span>
    }

    @Override
    public synchronized int read(boolean[] b, int start, int length) throws IOException {
<span class="fc" id="L265">        return getDecoder().read(b, start, length);</span>
    }
    
    @Override
    public final synchronized int read(Boolean[] buf) throws IOException {
<span class="fc" id="L270">        return read(buf, 0, buf.length);</span>
    }

    @Override
    public synchronized int read(Boolean[] buf, int offset, int size) throws IOException {
<span class="fc" id="L275">        return getDecoder().read(buf, offset, size);</span>
    }

    @Override
    public final synchronized int read(char[] c) throws IOException {
<span class="fc" id="L280">        return read(c, 0, c.length);</span>
    }

    @Override
    public synchronized int read(char[] c, int start, int length) throws IOException {
<span class="fc" id="L285">        return getDecoder().read(c, start, length);</span>
    }

    @Override
    public final synchronized int read(short[] s) throws IOException {
<span class="fc" id="L290">        return read(s, 0, s.length);</span>
    }

    @Override
    public synchronized int read(short[] s, int start, int length) throws IOException {
<span class="fc" id="L295">        return getDecoder().read(s, start, length);</span>
    }

    @Override
    public final synchronized int read(int[] i) throws IOException {
<span class="fc" id="L300">        return read(i, 0, i.length);</span>
    }

    @Override
    public synchronized int read(int[] i, int start, int length) throws IOException {
<span class="fc" id="L305">        return getDecoder().read(i, start, length);</span>
    }

    @Override
    public final synchronized int read(long[] l) throws IOException {
<span class="fc" id="L310">        return read(l, 0, l.length);</span>
    }

    @Override
    public synchronized int read(long[] l, int start, int length) throws IOException {
<span class="fc" id="L315">        return getDecoder().read(l, start, length);</span>
    }

    @Override
    public final synchronized int read(float[] f) throws IOException {
<span class="fc" id="L320">        return read(f, 0, f.length);</span>
    }

    @Override
    public synchronized int read(float[] f, int start, int length) throws IOException {
<span class="fc" id="L325">        return getDecoder().read(f, start, length);</span>
    }

    @Override
    public final synchronized int read(double[] d) throws IOException {
<span class="fc" id="L330">        return read(d, 0, d.length);</span>
    }

    @Override
    public synchronized int read(double[] d, int start, int length) throws IOException {
<span class="fc" id="L335">        return getDecoder().read(d, start, length);</span>
    }

    @Deprecated
    @Override
    public final synchronized int readArray(Object o) throws IOException {
<span class="fc" id="L341">        return (int) readLArray(o);</span>
    }
 
    @Override
    public boolean markSupported() {
<span class="fc" id="L346">        return true;</span>
    }

    @Override
    public synchronized void mark(int readlimit) throws IOException {
<span class="fc" id="L351">        marker = getFilePointer();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        if (!hasAvailable(readlimit)) {</span>
<span class="fc" id="L353">            FitsFile.LOG.log(Level.FINE, &quot;mark over file limit, so read as far as possible.&quot;);</span>
        }
<span class="fc" id="L355">    }</span>

    @Override
    public synchronized void reset() throws IOException {
<span class="fc" id="L359">        seek(marker);</span>
<span class="fc" id="L360">    }</span>

    @Override   
    public synchronized int skipBytes(int toSkip) throws IOException {
<span class="fc" id="L364">        return (int) skip(toSkip);</span>
    }

    @Override
    public final synchronized void skipAllBytes(int toSkip) throws IOException {
<span class="fc" id="L369">        skipAllBytes((long) toSkip);</span>
<span class="fc" id="L370">    }</span>

    @Override
    public synchronized void skipAllBytes(long toSkip) throws IOException {        
<span class="fc" id="L374">        long n = skip(toSkip);</span>
        
        // Note that we allow negative skips...
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (n != toSkip) {</span>
<span class="fc" id="L378">            throw new EOFException(&quot;Skip reached file boundary at &quot; + n + &quot; of &quot; + toSkip);</span>
        }
<span class="fc" id="L380">    }</span>
   
    @Override
    public final synchronized void writeByte(int v) throws IOException {
<span class="fc" id="L384">        getEncoder().writeByte(v);</span>
<span class="fc" id="L385">    }</span>

    @Override
    public synchronized void writeBoolean(boolean v) throws IOException {
<span class="fc" id="L389">        getEncoder().writeBoolean(v);</span>
<span class="fc" id="L390">    }</span>

    @Override
    public synchronized void writeBoolean(Boolean v) throws IOException {
<span class="fc" id="L394">        getEncoder().writeBoolean(v);</span>
<span class="fc" id="L395">    }</span>

    @Override
    public synchronized void writeChar(int v) throws IOException {
<span class="fc" id="L399">        getEncoder().writeChar(v);</span>
<span class="fc" id="L400">    }</span>

    @Override
    public final synchronized void writeShort(int v) throws IOException {
<span class="fc" id="L404">        getEncoder().writeShort(v);</span>
<span class="fc" id="L405">    }</span>

    @Override
    public final synchronized void writeInt(int v) throws IOException {
<span class="fc" id="L409">        getEncoder().writeInt(v);</span>
<span class="fc" id="L410">    }</span>

    @Override
    public final synchronized void writeLong(long v) throws IOException {
<span class="fc" id="L414">        getEncoder().writeLong(v);</span>
<span class="fc" id="L415">    }</span>

    @Override
    public final synchronized void writeFloat(float v) throws IOException {
<span class="fc" id="L419">        getEncoder().writeFloat(v);</span>
<span class="fc" id="L420">    }</span>

    @Override
    public final synchronized void writeDouble(double v) throws IOException {
<span class="fc" id="L424">        getEncoder().writeDouble(v);</span>
<span class="fc" id="L425">    }</span>

    @Override
    public final synchronized void writeBytes(String s) throws IOException {
<span class="fc" id="L429">        getEncoder().writeBytes(s);</span>
<span class="fc" id="L430">    }</span>

    @Override
    public final synchronized void writeChars(String s) throws IOException {
<span class="fc" id="L434">        getEncoder().writeChars(s);</span>
<span class="fc" id="L435">    }</span>

    @Override
    public final synchronized void write(boolean[] b) throws IOException {
<span class="fc" id="L439">        write(b, 0, b.length);</span>
<span class="fc" id="L440">    }</span>

    @Override
    public synchronized void write(boolean[] b, int start, int length) throws IOException {
<span class="fc" id="L444">        getEncoder().write(b, start, length);</span>
<span class="fc" id="L445">    }</span>

    @Override
    public final synchronized void write(Boolean[] buf) throws IOException {
<span class="fc" id="L449">        write(buf, 0, buf.length);</span>
<span class="fc" id="L450">    }</span>

    @Override
    public synchronized void write(Boolean[] buf, int offset, int size) throws IOException {
<span class="fc" id="L454">        getEncoder().write(buf, offset, size);</span>
<span class="fc" id="L455">    }</span>
    
    @Override
    public final synchronized void write(char[] c) throws IOException {
<span class="fc" id="L459">        write(c, 0, c.length);</span>
<span class="fc" id="L460">    }</span>

    @Override
    public synchronized void write(char[] c, int start, int length) throws IOException {
<span class="fc" id="L464">        getEncoder().write(c, start, length);</span>
<span class="fc" id="L465">    }</span>

    @Override
    public final synchronized void write(short[] s) throws IOException {
<span class="fc" id="L469">        write(s, 0, s.length);</span>
<span class="fc" id="L470">    }</span>

    @Override
    public synchronized void write(short[] s, int start, int length) throws IOException {
<span class="fc" id="L474">        getEncoder().write(s, start, length);</span>
<span class="fc" id="L475">    }</span>

    @Override
    public final synchronized void write(int[] i) throws IOException {
<span class="fc" id="L479">        write(i, 0, i.length);</span>
<span class="fc" id="L480">    }</span>

    @Override
    public synchronized void write(int[] i, int start, int length) throws IOException {
<span class="fc" id="L484">        getEncoder().write(i, start, length);</span>
<span class="fc" id="L485">    }</span>

    @Override
    public final synchronized void write(long[] l) throws IOException {
<span class="fc" id="L489">        write(l, 0, l.length);</span>
<span class="fc" id="L490">    }</span>

    @Override
    public synchronized void write(long[] l, int start, int length) throws IOException {
<span class="fc" id="L494">        getEncoder().write(l, start, length);</span>
<span class="fc" id="L495">    }</span>

    @Override
    public final synchronized void write(float[] f) throws IOException {
<span class="fc" id="L499">        write(f, 0, f.length);</span>
<span class="fc" id="L500">    }</span>

    @Override
    public synchronized void write(float[] f, int start, int length) throws IOException {
<span class="fc" id="L504">        getEncoder().write(f, start, length);</span>
<span class="fc" id="L505">    }</span>

    @Override
    public final synchronized void write(double[] d) throws IOException {
<span class="fc" id="L509">        write(d, 0, d.length);</span>
<span class="fc" id="L510">    }</span>

    @Override
    public synchronized void write(double[] d, int start, int length) throws IOException {
<span class="fc" id="L514">        getEncoder().write(d, start, length);</span>
<span class="fc" id="L515">    }</span>

    @Override
    public final synchronized void write(String[] s) throws IOException {
<span class="fc" id="L519">        write(s, 0, s.length);</span>
<span class="fc" id="L520">    }</span>

    @Override
    public synchronized void write(String[] s, int start, int length) throws IOException {
<span class="fc" id="L524">        getEncoder().write(s, start, length);</span>
<span class="fc" id="L525">    }</span>
    
    @Override
    public synchronized boolean checkTruncated() throws IOException {
<span class="fc" id="L529">        long pos = getFilePointer();</span>
<span class="fc" id="L530">        long len = length();</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (pos &gt; len) {</span>
<span class="fc" id="L532">            LOG.log(Level.WARNING, &quot;Premature file end at &quot; + len + &quot; (expected &quot; + pos + &quot;)&quot;, new Throwable());</span>
<span class="fc" id="L533">            return true;</span>
        }
<span class="fc" id="L535">        return false;</span>
    }

    @Override
    public final synchronized long position() {
<span class="fc" id="L540">        return getFilePointer();</span>
    }

    @Override
    public final synchronized void position(long n) throws IOException {
<span class="fc" id="L545">        seek(n);</span>
<span class="fc" id="L546">    }</span>
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>