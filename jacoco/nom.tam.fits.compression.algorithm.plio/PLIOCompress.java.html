<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PLIOCompress.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.fits.compression.algorithm.plio</a> &gt; <span class="el_source">PLIOCompress.java</span></div><h1>PLIOCompress.java</h1><pre class="source lang-java linenums">package nom.tam.fits.compression.algorithm.plio;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;

import nom.tam.fits.compression.algorithm.api.ICompressor;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

/**
 * The original decompression code was written by Doug Tody, NRAO and included
 * (ported to c and adapted) in cfitsio by William Pence, NASA/GSFC. That code
 * was then ported to Java by R. van Nieuwenhoven. Later it was massively
 * refactored to harmonize the different compression algorithms and reduce the
 * duplicate code pieces without obscuring the algorithm itself as good as
 * possible.
 *
 * @author Doug Tody
 * @author William Pence
 * @author Richard van Nieuwenhoven
 */
<span class="fc" id="L52">public abstract class PLIOCompress {</span>

<span class="fc" id="L54">    public static class BytePLIOCompressor extends PLIOCompress implements ICompressor&lt;ByteBuffer&gt; {</span>

        private ByteBuffer pixelData;

        @Override
        public boolean compress(ByteBuffer buffer, ByteBuffer compressed) {
<span class="fc" id="L60">            this.pixelData = buffer;</span>
<span class="fc" id="L61">            compress(compressed.asShortBuffer(), this.pixelData.limit());</span>
<span class="fc" id="L62">            return true;</span>
        }

        @Override
        public void decompress(ByteBuffer compressed, ByteBuffer buffer) {
<span class="fc" id="L67">            this.pixelData = buffer;</span>
<span class="fc" id="L68">            decompress(compressed.asShortBuffer(), this.pixelData.limit());</span>
<span class="fc" id="L69">        }</span>

        @Override
        protected int nextPixel() {
<span class="fc" id="L73">            return this.pixelData.get();</span>
        }

        @Override
        protected void put(int index, int pixel) {
<span class="fc" id="L78">            this.pixelData.put(index, (byte) pixel);</span>
<span class="fc" id="L79">        }</span>
    }

<span class="fc" id="L82">    public static class ShortPLIOCompressor extends PLIOCompress implements ICompressor&lt;ShortBuffer&gt; {</span>

        private ShortBuffer pixelData;

        @Override
        public boolean compress(ShortBuffer buffer, ByteBuffer compressed) {
<span class="fc" id="L88">            this.pixelData = buffer;</span>
<span class="fc" id="L89">            super.compress(compressed.asShortBuffer(), this.pixelData.limit());</span>
<span class="fc" id="L90">            return true;</span>
        }

        @Override
        public void decompress(ByteBuffer compressed, ShortBuffer buffer) {
<span class="fc" id="L95">            this.pixelData = buffer;</span>
<span class="fc" id="L96">            decompress(compressed.asShortBuffer(), this.pixelData.limit());</span>
<span class="fc" id="L97">        }</span>

        @Override
        protected int nextPixel() {
<span class="fc" id="L101">            return this.pixelData.get();</span>
        }

        @Override
        protected void put(int index, int pixel) {
<span class="fc" id="L106">            this.pixelData.put(index, (short) pixel);</span>
<span class="fc" id="L107">        }</span>
    }

    /**
     * Attention int values are limited to 24 bits!
     */
<span class="fc" id="L113">    public static class IntPLIOCompressor extends PLIOCompress implements ICompressor&lt;IntBuffer&gt; {</span>

        private IntBuffer pixelData;

        @Override
        public boolean compress(IntBuffer buffer, ByteBuffer compressed) {
<span class="fc" id="L119">            this.pixelData = buffer;</span>
<span class="fc" id="L120">            super.compress(compressed.asShortBuffer(), this.pixelData.limit());</span>
<span class="fc" id="L121">            return true;</span>
        }

        @Override
        public void decompress(ByteBuffer compressed, IntBuffer buffer) {
<span class="fc" id="L126">            this.pixelData = buffer;</span>
<span class="fc" id="L127">            decompress(compressed.asShortBuffer(), this.pixelData.limit());</span>
<span class="fc" id="L128">        }</span>

        @Override
        protected int nextPixel() {
<span class="fc" id="L132">            return this.pixelData.get();</span>
        }

        @Override
        protected void put(int index, int pixel) {
<span class="fc" id="L137">            this.pixelData.put(index, (short) pixel);</span>
<span class="fc" id="L138">        }</span>
    }

    private static final int FIRST_VALUE_WITH_13_BIT = 4096;

    private static final int FIRST_VALUE_WITH_14_BIT = 8192;

    private static final int FIRST_VALUE_WITH_15_BIT = 16384;

    private static final int FIRST_VALUE_WITH_16_BIT = 32768;

    private static final int HEADER_SIZE_FIELD1 = 3;

    private static final int HEADER_SIZE_FIELD2 = 4;

    private static final int LAST_VALUE_FITTING_IN_12_BIT = FIRST_VALUE_WITH_13_BIT - 1;

    private static final int MINI_HEADER_SIZE = 3;

    private static final int MINI_HEADER_SIZE_FIELD = 2;

    /**
     * The exact meaning of this var is not clear at the moment of porting the
     * algorithm to Java.
     */
    private static final int N20481 = 20481;

    private static final int OPCODE_1 = 1;

    private static final int OPCODE_2 = 2;

    private static final int OPCODE_3 = 3;

    private static final int OPCODE_4 = 4;

    private static final int OPCODE_5 = 5;

    private static final int OPCODE_6 = 6;

    private static final int OPCODE_7 = 7;

    private static final int OPCODE_8 = 8;

<span class="fc" id="L181">    private static final short[] PLIO_HEADER = {</span>
        (short) 0,
        (short) 7,
        (short) -100,
        (short) 0,
        (short) 0,
        (short) 0,
        (short) 0
    };

    private static final int SHIFT_12_BITS = 12;

    private static final int SHIFT_15_BITS = 15;

    private static final int VALUE_OF_BIT_13_AND14_ON = 12288;

    /**
     * PL_P2L -- Convert a pixel tiledImageOperation to a line list. The length
     * of the list is returned as the function value.
     *
     * @param compressedData
     *            encoded line list
     * @param npix
     *            number of pixels to convert
     */
    protected void compress(ShortBuffer compressedData, int npix) {
<span class="fc" id="L207">        compressedData.put(PLIO_HEADER);</span>
<span class="fc" id="L208">        final int xe = npix - 1;</span>
<span class="fc" id="L209">        int op = PLIO_HEADER.length;</span>
        /* Computing MAX */
<span class="fc" id="L211">        int pv = Math.max(0, nextPixel());</span>
<span class="fc" id="L212">        int x1 = 0;</span>
<span class="fc" id="L213">        int iz = 0;</span>
<span class="fc" id="L214">        int hi = 1;</span>
<span class="fc" id="L215">        int nv = 0;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (int ip = 0; ip &lt;= xe; ++ip) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            if (ip &lt; xe) {</span>
                /* Computing MAX */
<span class="fc" id="L219">                nv = Math.max(0, nextPixel());</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (nv == pv) {</span>
<span class="fc" id="L221">                    continue;</span>
                }
<span class="fc bfc" id="L223" title="All 2 branches covered.">                if (pv == 0) {</span>
<span class="fc" id="L224">                    pv = nv;</span>
<span class="fc" id="L225">                    x1 = ip + 1;</span>
<span class="fc" id="L226">                    continue;</span>
                }
            } else {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                if (pv == 0) {</span>
<span class="fc" id="L230">                    x1 = xe + 1;</span>
                }
            }

<span class="fc" id="L234">            int np = ip - x1 + 1;</span>
<span class="fc" id="L235">            int nz = x1 - iz;</span>
<span class="fc" id="L236">            boolean skip = false;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (pv &gt; 0) {</span>
<span class="fc" id="L238">                int dv = pv - hi;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                if (dv != 0) {</span>
<span class="fc" id="L240">                    hi = pv;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                    if (Math.abs(dv) &gt; LAST_VALUE_FITTING_IN_12_BIT) {</span>
<span class="fc" id="L242">                        compressedData.put(op, (short) ((pv &amp; LAST_VALUE_FITTING_IN_12_BIT) + FIRST_VALUE_WITH_13_BIT));</span>
<span class="fc" id="L243">                        ++op;</span>
<span class="fc" id="L244">                        compressedData.put(op, (short) (pv / FIRST_VALUE_WITH_13_BIT));</span>
<span class="fc" id="L245">                        ++op;</span>
                    } else {
<span class="fc bfc" id="L247" title="All 2 branches covered.">                        if (dv &lt; 0) {</span>
<span class="fc" id="L248">                            compressedData.put(op, (short) (-dv + VALUE_OF_BIT_13_AND14_ON));</span>
                        } else {
<span class="fc" id="L250">                            compressedData.put(op, (short) (dv + FIRST_VALUE_WITH_14_BIT));</span>
                        }
<span class="fc" id="L252">                        ++op;</span>
<span class="fc bfc" id="L253" title="All 4 branches covered.">                        if (np == 1 &amp;&amp; nz == 0) {</span>
<span class="fc" id="L254">                            int v = compressedData.get(op - 1);</span>
<span class="fc" id="L255">                            compressedData.put(op - 1, (short) (v | FIRST_VALUE_WITH_15_BIT));</span>
<span class="fc" id="L256">                            skip = true;</span>
                        }
                    }
                }
            }
<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (!skip) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">                if (nz &gt; 0) {</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                    while (nz &gt; 0) {</span>
<span class="fc" id="L264">                        compressedData.put(op, (short) Math.min(LAST_VALUE_FITTING_IN_12_BIT, nz));</span>
<span class="fc" id="L265">                        ++op;</span>
<span class="fc" id="L266">                        nz += -LAST_VALUE_FITTING_IN_12_BIT;</span>
                    }
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">                    if (np == 1 &amp;&amp; pv &gt; 0) {</span>
<span class="fc" id="L269">                        compressedData.put(op - 1, (short) (compressedData.get(op - 1) + N20481));</span>
<span class="fc" id="L270">                        skip = true;</span>
                    }
                }
            }
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (!skip) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">                while (np &gt; 0) {</span>
<span class="fc" id="L276">                    compressedData.put(op, (short) (Math.min(LAST_VALUE_FITTING_IN_12_BIT, np) + FIRST_VALUE_WITH_15_BIT));</span>
<span class="fc" id="L277">                    ++op;</span>
<span class="fc" id="L278">                    np += -LAST_VALUE_FITTING_IN_12_BIT;</span>
                }
            }
<span class="fc" id="L281">            x1 = ip + 1;</span>
<span class="fc" id="L282">            iz = x1;</span>
<span class="fc" id="L283">            pv = nv;</span>
        }
<span class="fc" id="L285">        compressedData.put(HEADER_SIZE_FIELD1, (short) (op % FIRST_VALUE_WITH_16_BIT));</span>
<span class="fc" id="L286">        compressedData.put(HEADER_SIZE_FIELD2, (short) (op / FIRST_VALUE_WITH_16_BIT));</span>
<span class="fc" id="L287">        compressedData.position(op);</span>
<span class="fc" id="L288">    }</span>

    /**
     * PL_L2PI -- Translate a PLIO line list into an integer pixel
     * tiledImageOperation. The number of pixels output (always npix) is
     * returned as the function value.
     *
     * @param compressedData
     *            encoded line list
     * @param npix
     *            number of pixels to convert
     * @return number of pixels converted
     */
    protected int decompress(ShortBuffer compressedData, int npix) {
        int llfirt;
        int lllen;
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (!(compressedData.get(2) &gt; 0)) {</span>
<span class="fc" id="L305">            lllen = (compressedData.get(HEADER_SIZE_FIELD2) &lt;&lt; SHIFT_15_BITS) + compressedData.get(HEADER_SIZE_FIELD1);</span>
<span class="fc" id="L306">            llfirt = compressedData.get(1);</span>
        } else {
<span class="fc" id="L308">            lllen = compressedData.get(MINI_HEADER_SIZE_FIELD);</span>
<span class="fc" id="L309">            llfirt = MINI_HEADER_SIZE;</span>
        }
<span class="fc" id="L311">        final int xe = npix;</span>
<span class="fc" id="L312">        int op = 0;</span>
<span class="fc" id="L313">        int x1 = 1;</span>
<span class="fc" id="L314">        int pv = 1;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        for (int ip = llfirt; ip &lt;= lllen; ++ip) {</span>
<span class="fc" id="L316">            final int opcode = compressedData.get(ip) / FIRST_VALUE_WITH_13_BIT;</span>
<span class="fc" id="L317">            final int data = compressedData.get(ip) &amp; LAST_VALUE_FITTING_IN_12_BIT;</span>
<span class="fc" id="L318">            final int sw0001 = opcode + 1;</span>
<span class="fc bfc" id="L319" title="All 6 branches covered.">            if (sw0001 == OPCODE_1 || sw0001 == OPCODE_5 || sw0001 == OPCODE_6) {</span>
<span class="fc" id="L320">                final int x2 = x1 + data - 1;</span>
<span class="fc" id="L321">                final int i2 = Math.min(x2, xe);</span>
<span class="fc" id="L322">                final int np = i2 - Math.max(x1, 0) + 1;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">                if (np &gt; 0) {</span>
<span class="fc" id="L324">                    final int otop = op + np - 1;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">                    if (!(opcode == OPCODE_4)) {</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">                        for (int index = op; index &lt;= otop; ++index) {</span>
<span class="fc" id="L327">                            put(index, 0);</span>
                        }
<span class="pc bpc" id="L329" title="1 of 4 branches missed.">                        if (opcode == OPCODE_5 &amp;&amp; i2 == x2) {</span>
<span class="fc" id="L330">                            put(otop, pv);</span>
                        }
                    } else {
<span class="fc bfc" id="L333" title="All 2 branches covered.">                        for (int index = op; index &lt;= otop; ++index) {</span>
<span class="fc" id="L334">                            put(index, pv);</span>
                        }
                    }
<span class="fc" id="L337">                    op = otop + 1;</span>
                }
<span class="fc" id="L339">                x1 = x2 + 1;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            } else if (sw0001 == OPCODE_2) {</span>
<span class="fc" id="L341">                pv = (compressedData.get(ip + 1) &lt;&lt; SHIFT_12_BITS) + data;</span>
<span class="fc" id="L342">                ++ip;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            } else if (sw0001 == OPCODE_3) {</span>
<span class="fc" id="L344">                pv += data;</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            } else if (sw0001 == OPCODE_4) {</span>
<span class="fc" id="L346">                pv -= data;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">            } else if (sw0001 == OPCODE_7) {</span>
<span class="fc" id="L348">                pv += data;</span>
<span class="pc bpc" id="L349" title="2 of 4 branches missed.">                if (x1 &gt;= 0 &amp;&amp; x1 &lt;= xe) {</span>
<span class="fc" id="L350">                    put(op, pv);</span>
<span class="fc" id="L351">                    ++op;</span>
                }
<span class="fc" id="L353">                ++x1;</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            } else if (sw0001 == OPCODE_8) {</span>
<span class="fc" id="L355">                pv -= data;</span>
<span class="pc bpc" id="L356" title="2 of 4 branches missed.">                if (x1 &gt;= 0 &amp;&amp; x1 &lt;= xe) {</span>
<span class="fc" id="L357">                    put(op, pv);</span>
<span class="fc" id="L358">                    ++op;</span>
                }
<span class="fc" id="L360">                ++x1;</span>
            }
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (x1 &gt; xe) {</span>
<span class="fc" id="L363">                break;</span>
            }
        }
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int index = op; index &lt; npix; ++index) {</span>
<span class="fc" id="L367">            put(index, 0);</span>
        }
<span class="fc" id="L369">        return npix;</span>
    }

    protected abstract int nextPixel();

    protected abstract void put(int index, int pixel);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>