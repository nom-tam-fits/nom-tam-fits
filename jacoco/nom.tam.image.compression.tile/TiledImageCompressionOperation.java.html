<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TiledImageCompressionOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.image.compression.tile</a> &gt; <span class="el_source">TiledImageCompressionOperation.java</span></div><h1>TiledImageCompressionOperation.java</h1><pre class="source lang-java linenums">package nom.tam.image.compression.tile;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

import static nom.tam.fits.header.Compression.COMPRESSED_DATA_COLUMN;
import static nom.tam.fits.header.Compression.GZIP_COMPRESSED_DATA_COLUMN;
import static nom.tam.fits.header.Compression.NULL_PIXEL_MASK_COLUMN;
import static nom.tam.fits.header.Compression.UNCOMPRESSED_DATA_COLUMN;
import static nom.tam.fits.header.Compression.ZBITPIX;
import static nom.tam.fits.header.Compression.ZCMPTYPE;
import static nom.tam.fits.header.Compression.ZCMPTYPE_GZIP_1;
import static nom.tam.fits.header.Compression.ZMASKCMP;
import static nom.tam.fits.header.Compression.ZNAXIS;
import static nom.tam.fits.header.Compression.ZNAXISn;
import static nom.tam.fits.header.Compression.ZQUANTIZ;
import static nom.tam.fits.header.Compression.ZTILEn;
import static nom.tam.fits.header.Standard.TTYPEn;
import static nom.tam.image.compression.tile.TileCompressionType.COMPRESSED;
import static nom.tam.image.compression.tile.TileCompressionType.GZIP_COMPRESSED;
import static nom.tam.image.compression.tile.TileCompressionType.UNCOMPRESSED;

import java.lang.reflect.Array;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;

import nom.tam.fits.BinaryTable;
import nom.tam.fits.BinaryTableHDU;
import nom.tam.fits.FitsException;
import nom.tam.fits.FitsFactory;
import nom.tam.fits.Header;
import nom.tam.fits.HeaderCard;
import nom.tam.fits.HeaderCardBuilder;
import nom.tam.fits.compression.algorithm.api.ICompressOption;
import nom.tam.fits.compression.algorithm.api.ICompressorControl;
import nom.tam.fits.compression.provider.CompressorProvider;
import nom.tam.fits.compression.provider.param.api.HeaderAccess;
import nom.tam.fits.compression.provider.param.api.HeaderCardAccess;
import nom.tam.image.compression.tile.mask.ImageNullPixelMask;
import nom.tam.image.tile.operation.AbstractTiledImageOperation;
import nom.tam.image.tile.operation.TileArea;
import nom.tam.util.type.ElementType;

/**
 * This class represents a complete tiledImageOperation of tileOperations
 * describing an image ordered from left to right and top down. the
 * tileOperations all have the same geometry only the tileOperations at the
 * right side and the bottom side can have different sizes.
 */
public class TiledImageCompressionOperation extends AbstractTiledImageOperation&lt;TileCompressionOperation&gt; {

    /**
     * ZCMPTYPE name of the algorithm that was used to compress
     */
    private String compressAlgorithm;

    private final BinaryTable binaryTable;

    private ByteBuffer compressedWholeArea;

    // Note: field is initialized lazily: use getter within class!
    private ICompressorControl compressorControl;

    // Note: field is initialized lazily: use getter within class!
    private ICompressorControl gzipCompressorControl;

    /**
     * ZQUANTIZ name of the algorithm that was used to quantize
     */
    private String quantAlgorithm;

    private ICompressOption imageOptions;

    private ImageNullPixelMask imageNullPixelMask;

    private static void addColumnToTable(BinaryTableHDU hdu, Object column, String columnName) throws FitsException {
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (column != null) {</span>
<span class="fc" id="L108">            hdu.setColumnName(hdu.addColumn(column) - 1, columnName, null);</span>
        }
<span class="fc" id="L110">    }</span>

    private static void setNullEntries(Object column, Object defaultValue) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (column != null) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (int index = 0; index &lt; Array.getLength(column); index++) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (Array.get(column, index) == null) {</span>
<span class="fc" id="L116">                    Array.set(column, index, defaultValue);</span>
                }
            }
        }
<span class="fc" id="L120">    }</span>

    /**
     * create a TiledImageCompressionOperation based on a compressed image data.
     *
     * @param binaryTable
     *            the compressed image data.
     */
    public TiledImageCompressionOperation(BinaryTable binaryTable) {
<span class="fc" id="L129">        super(TileCompressionOperation.class);</span>
<span class="fc" id="L130">        this.binaryTable = binaryTable;</span>
<span class="fc" id="L131">    }</span>

    public void compress(BinaryTableHDU hdu) throws FitsException {
<span class="fc" id="L134">        processAllTiles();</span>
<span class="fc" id="L135">        writeColumns(hdu);</span>
<span class="fc" id="L136">        writeHeader(hdu.getHeader());</span>
<span class="fc" id="L137">    }</span>

    @Override
    public ICompressOption compressOptions() {
<span class="fc" id="L141">        initializeCompressionControl();</span>
<span class="fc" id="L142">        return this.imageOptions;</span>
    }

    public Buffer decompress() {
<span class="fc" id="L146">        Buffer decompressedWholeArea = getBaseType().newBuffer(getBufferSize());</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L148">            tileOperation.setWholeImageBuffer(decompressedWholeArea);</span>
        }
<span class="fc" id="L150">        processAllTiles();</span>
<span class="fc" id="L151">        decompressedWholeArea.rewind();</span>
<span class="fc" id="L152">        return decompressedWholeArea;</span>
    }

    public void forceNoLoss(int x, int y, int width, int heigth) {
<span class="fc" id="L156">        TileArea tileArea = new TileArea().start(x, y).end(x + width, y + heigth);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        for (TileCompressionOperation operation : getTileOperations()) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">            if (operation.getArea().intersects(tileArea)) {</span>
<span class="fc" id="L159">                operation.forceNoLoss(true);</span>
            }
        }
<span class="fc" id="L162">    }</span>

    @Override
    public ByteBuffer getCompressedWholeArea() {
<span class="fc" id="L166">        return this.compressedWholeArea;</span>
    }

    @Override
    public ICompressorControl getCompressorControl() {
<span class="fc" id="L171">        initializeCompressionControl();</span>
<span class="fc" id="L172">        return this.compressorControl;</span>
    }

    @Override
    public ICompressorControl getGzipCompressorControl() {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (this.gzipCompressorControl == null) {</span>
<span class="fc" id="L178">            this.gzipCompressorControl = CompressorProvider.findCompressorControl(null, ZCMPTYPE_GZIP_1, getBaseType().primitiveClass());</span>
        }
<span class="fc" id="L180">        return this.gzipCompressorControl;</span>
    }

    public TiledImageCompressionOperation prepareUncompressedData(final Buffer buffer) throws FitsException {
<span class="fc" id="L184">        this.compressedWholeArea = ByteBuffer.wrap(new byte[getBaseType().size() * getBufferSize()]);</span>
<span class="fc" id="L185">        createTiles(new TileCompressorInitialisation(this, buffer));</span>
<span class="fc" id="L186">        this.compressedWholeArea.rewind();</span>
<span class="fc" id="L187">        return this;</span>
    }

    /**
     * preserve null values, where the value representing null is specified as a
     * parameter. This parameter is ignored for floating point values where NaN
     * is used as null value.
     *
     * @param nullValue
     *            the value representing null for byte/short and integer pixel
     *            values
     * @param compressionAlgorithm
     *            compression algorithm to use for the null pixel mask
     * @return the created null pixel mask
     */
    public ImageNullPixelMask preserveNulls(long nullValue, String compressionAlgorithm) {
<span class="fc" id="L203">        this.imageNullPixelMask = new ImageNullPixelMask(getTileOperations().length, nullValue, compressionAlgorithm);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L205">            tileOperation.createImageNullPixelMask(getImageNullPixelMask());</span>
        }
<span class="fc" id="L207">        return this.imageNullPixelMask;</span>
    }

    public TiledImageCompressionOperation read(final Header header) throws FitsException {
<span class="fc" id="L211">        readPrimaryHeaders(header);</span>
<span class="fc" id="L212">        setCompressAlgorithm(header.findCard(ZCMPTYPE));</span>
<span class="fc" id="L213">        setQuantAlgorithm(header.findCard(ZQUANTIZ));</span>
<span class="fc" id="L214">        createTiles(new TileDecompressorInitialisation(this, //</span>
<span class="fc" id="L215">                getNullableColumn(header, Object[].class, UNCOMPRESSED_DATA_COLUMN), //</span>
<span class="fc" id="L216">                getNullableColumn(header, Object[].class, COMPRESSED_DATA_COLUMN), //</span>
<span class="fc" id="L217">                getNullableColumn(header, Object[].class, GZIP_COMPRESSED_DATA_COLUMN), //</span>
                new HeaderAccess(header)));
<span class="fc" id="L219">        byte[][] nullPixels = getNullableColumn(header, byte[][].class, NULL_PIXEL_MASK_COLUMN);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (nullPixels != null) {</span>
<span class="fc" id="L221">            preserveNulls(0L, header.getStringValue(ZMASKCMP)).setColumn(nullPixels);</span>
        }
<span class="fc" id="L223">        readCompressionHeaders(header);</span>
<span class="fc" id="L224">        return this;</span>
    }

    public void readPrimaryHeaders(Header header) throws FitsException {
<span class="fc" id="L228">        readBaseType(header);</span>
<span class="fc" id="L229">        readAxis(header);</span>
<span class="fc" id="L230">        readTileAxis(header);</span>
<span class="fc" id="L231">    }</span>

    public TiledImageCompressionOperation setCompressAlgorithm(HeaderCard compressAlgorithmCard) {
<span class="fc" id="L234">        this.compressAlgorithm = compressAlgorithmCard.getValue();</span>
<span class="fc" id="L235">        return this;</span>
    }

    public TiledImageCompressionOperation setQuantAlgorithm(HeaderCard quantAlgorithmCard) {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (quantAlgorithmCard != null) {</span>
<span class="fc" id="L240">            this.quantAlgorithm = quantAlgorithmCard.getValue();</span>
        } else {
<span class="fc" id="L242">            this.quantAlgorithm = null;</span>
        }
<span class="fc" id="L244">        return this;</span>
    }

    private &lt;T&gt; T getNullableColumn(Header header, Class&lt;T&gt; class1, String columnName) throws FitsException {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (int i = 1; i &lt;= this.binaryTable.getNCols(); i++) {</span>
<span class="fc" id="L249">            String val = header.getStringValue(TTYPEn.n(i));</span>
<span class="pc bpc" id="L250" title="1 of 4 branches missed.">            if (val != null &amp;&amp; val.trim().equals(columnName)) {</span>
<span class="fc" id="L251">                return class1.cast(this.binaryTable.getColumn(i - 1));</span>
            }
        }
<span class="fc" id="L254">        return null;</span>
    }

    private void initializeCompressionControl() {
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (this.compressorControl == null) {</span>
<span class="fc" id="L259">            this.compressorControl = CompressorProvider.findCompressorControl(this.quantAlgorithm, this.compressAlgorithm, getBaseType().primitiveClass());</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (this.compressorControl == null) {</span>
<span class="fc" id="L261">                throw new IllegalStateException(&quot;Found no compressor control for compression algorithm:&quot; + this.compressAlgorithm + //</span>
<span class="fc" id="L262">                        &quot; (quantize algorithm = &quot; + this.quantAlgorithm + &quot;, base type = &quot; + getBaseType().primitiveClass() + &quot;)&quot;);</span>
            }
<span class="fc" id="L264">            initImageOptions();</span>
        }
<span class="fc" id="L266">    }</span>

    private void initImageOptions() {
<span class="fc" id="L269">        this.imageOptions = this.compressorControl.option();</span>
<span class="fc" id="L270">        initializeQuantAlgorithm();</span>
<span class="fc" id="L271">        this.imageOptions.getCompressionParameters().initializeColumns(getNumberOfTileOperations());</span>
<span class="fc" id="L272">    }</span>

    private void processAllTiles() {
<span class="fc" id="L275">        ExecutorService threadPool = FitsFactory.threadPool();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L277">            tileOperation.execute(threadPool);</span>
        }
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L280">            tileOperation.waitForResult();</span>
        }
<span class="fc" id="L282">    }</span>

    private void readAxis(Header header) throws FitsException {
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (areAxesUndefined()) {</span>
<span class="fc" id="L286">            int naxis = header.getIntValue(ZNAXIS);</span>
<span class="fc" id="L287">            int[] axes = new int[naxis];</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            for (int i = 1; i &lt;= naxis; i++) {</span>
<span class="fc" id="L289">                int axisValue = header.getIntValue(ZNAXISn.n(i), -1);</span>
<span class="fc" id="L290">                axes[i - 1] = axisValue;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                if (axes[i - 1] == -1) {</span>
<span class="fc" id="L292">                    throw new FitsException(&quot;Required ZNAXISn not found&quot;);</span>
                }
            }
<span class="fc" id="L295">            setAxes(axes);</span>
        }
<span class="fc" id="L297">    }</span>

    private void readBaseType(Header header) {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (getBaseType() == null) {</span>
<span class="fc" id="L301">            int zBitPix = header.getIntValue(ZBITPIX);</span>
<span class="fc" id="L302">            ElementType&lt;Buffer&gt; elementType = ElementType.forNearestBitpix(zBitPix);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">            if (elementType == ElementType.UNKNOWN) {</span>
<span class="nc" id="L304">                throw new IllegalArgumentException(&quot;illegal value for ZBITPIX &quot; + zBitPix);</span>
            }
<span class="fc" id="L306">            setBaseType(elementType);</span>
        }
<span class="fc" id="L308">    }</span>

    private void readCompressionHeaders(Header header) {
<span class="fc" id="L311">        compressOptions().getCompressionParameters().getValuesFromHeader(new HeaderAccess(header));</span>
<span class="fc" id="L312">    }</span>

    private void readTileAxis(Header header) throws FitsException {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (areTileAxesUndefined()) {</span>
<span class="fc" id="L316">            int[] tileAxes = new int[getNAxes()];</span>
<span class="fc" id="L317">            Arrays.fill(tileAxes, 1);</span>
<span class="fc" id="L318">            tileAxes[0] = -1;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            for (int i = 1; i &lt;= tileAxes.length; i++) {</span>
<span class="fc" id="L320">                HeaderCard card = header.findCard(ZTILEn.n(i));</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">                if (card != null) {</span>
<span class="fc" id="L322">                    tileAxes[i - 1] = card.getValue(Integer.class, -1);</span>
                }
            }
<span class="fc" id="L325">            setTileAxes(tileAxes);</span>
        }
<span class="fc" id="L327">    }</span>

    private &lt;T&gt; Object setInColumn(Object column, boolean predicate, TileCompressionOperation tileOperation, Class&lt;T&gt; clazz, T value) {
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (predicate) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (column == null) {</span>
<span class="fc" id="L332">                column = Array.newInstance(clazz, getNumberOfTileOperations());</span>
            }
<span class="fc" id="L334">            Array.set(column, tileOperation.getTileIndex(), value);</span>
        }
<span class="fc" id="L336">        return column;</span>
    }

    private void writeColumns(BinaryTableHDU hdu) throws FitsException {
<span class="fc" id="L340">        Object compressedColumn = null;</span>
<span class="fc" id="L341">        Object uncompressedColumn = null;</span>
<span class="fc" id="L342">        Object gzipColumn = null;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (TileCompressionOperation tileOperation : getTileOperations()) {</span>
<span class="fc" id="L344">            TileCompressionType compression = tileOperation.getCompressionType();</span>
<span class="fc" id="L345">            byte[] compressedData = tileOperation.getCompressedData();</span>

<span class="fc bfc" id="L347" title="All 2 branches covered.">            compressedColumn = setInColumn(compressedColumn, compression == COMPRESSED, tileOperation, byte[].class, compressedData);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            gzipColumn = setInColumn(gzipColumn, compression == GZIP_COMPRESSED, tileOperation, byte[].class, compressedData);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">            uncompressedColumn = setInColumn(uncompressedColumn, compression == UNCOMPRESSED, tileOperation, byte[].class, compressedData);</span>
        }
<span class="fc" id="L351">        setNullEntries(compressedColumn, new byte[0]);</span>
<span class="fc" id="L352">        setNullEntries(gzipColumn, new byte[0]);</span>
<span class="fc" id="L353">        setNullEntries(uncompressedColumn, new byte[0]);</span>
<span class="fc" id="L354">        addColumnToTable(hdu, compressedColumn, COMPRESSED_DATA_COLUMN);</span>
<span class="fc" id="L355">        addColumnToTable(hdu, gzipColumn, GZIP_COMPRESSED_DATA_COLUMN);</span>
<span class="fc" id="L356">        addColumnToTable(hdu, uncompressedColumn, UNCOMPRESSED_DATA_COLUMN);</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (this.imageNullPixelMask != null) {</span>
<span class="fc" id="L358">            addColumnToTable(hdu, this.imageNullPixelMask.getColumn(), NULL_PIXEL_MASK_COLUMN);</span>
        }
<span class="fc" id="L360">        this.imageOptions.getCompressionParameters().addColumnsToTable(hdu);</span>
<span class="fc" id="L361">        hdu.getData().fillHeader(hdu.getHeader());</span>
<span class="fc" id="L362">    }</span>

    private void writeHeader(Header header) throws FitsException {
<span class="fc" id="L365">        HeaderCardBuilder cardBuilder = header//</span>
<span class="fc" id="L366">                .card(ZBITPIX).value(getBaseType().bitPix())//</span>
<span class="fc" id="L367">                .card(ZCMPTYPE).value(this.compressAlgorithm);</span>
<span class="fc" id="L368">        int[] tileAxes = getTileAxes();</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        for (int i = 1; i &lt;= tileAxes.length; i++) {</span>
<span class="fc" id="L370">            cardBuilder.card(ZTILEn.n(i)).value(tileAxes[i - 1]);</span>
        }
<span class="fc" id="L372">        compressOptions().getCompressionParameters().setValuesInHeader(new HeaderAccess(header));</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (this.imageNullPixelMask != null) {</span>
<span class="fc" id="L374">            cardBuilder.card(ZMASKCMP).value(this.imageNullPixelMask.getCompressAlgorithm());</span>
        }
<span class="fc" id="L376">    }</span>

    protected BinaryTable getBinaryTable() {
<span class="fc" id="L379">        return this.binaryTable;</span>
    }

    protected ImageNullPixelMask getImageNullPixelMask() {
<span class="fc" id="L383">        return this.imageNullPixelMask;</span>
    }

    protected void initializeQuantAlgorithm() {
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (this.quantAlgorithm != null) {</span>
<span class="fc" id="L388">            this.imageOptions.getCompressionParameters().getValuesFromHeader(new HeaderCardAccess(ZQUANTIZ, this.quantAlgorithm));</span>
        }
<span class="fc" id="L390">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>