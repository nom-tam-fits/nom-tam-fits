<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RiceCompressor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nom.tam FITS library</a> &gt; <a href="index.source.html" class="el_package">nom.tam.fits.compression.algorithm.rice</a> &gt; <span class="el_source">RiceCompressor.java</span></div><h1>RiceCompressor.java</h1><pre class="source lang-java linenums">package nom.tam.fits.compression.algorithm.rice;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
import java.util.logging.Logger;

import nom.tam.fits.compression.algorithm.api.ICompressor;
import nom.tam.fits.compression.algorithm.quant.QuantizeProcessor.DoubleQuantCompressor;
import nom.tam.fits.compression.algorithm.quant.QuantizeProcessor.FloatQuantCompressor;
import nom.tam.util.FitsIO;
import nom.tam.util.type.ElementType;

/*
 * #%L
 * nom.tam FITS library
 * %%
 * Copyright (C) 1996 - 2021 nom-tam-fits
 * %%
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * #L%
 */

/**
 * The original compression was designed by Rice, Yeh, and Miller the code was
 * written by Richard White at STSc at the STScI and included (ported to c and
 * adapted) in cfitsio by William Pence, NASA/GSFC. That code was then ported to
 * java by R. van Nieuwenhoven. Later it was massively refactored to harmonize
 * the different compression algorithms and reduce the duplicate code pieces
 * without obscuring the algorithm itself as far as possible.
 *
 * @author Richard White
 * @author William Pence
 * @author Richard van Nieuwenhoven
 * 
 * @param &lt;T&gt; the genetic type of NIO buffer on which this compressor operates.
 */
public abstract class RiceCompressor&lt;T extends Buffer&gt; implements ICompressor&lt;T&gt; {

    public static class ByteRiceCompressor extends RiceCompressor&lt;ByteBuffer&gt; {

        private ByteBuffer pixelBuffer;

        public ByteRiceCompressor(RiceCompressOption option) {
<span class="fc" id="L67">            super(option.setDefaultBytePix(ElementType.BYTE.size()));</span>
<span class="fc" id="L68">        }</span>

        @Override
        public boolean compress(ByteBuffer buffer, ByteBuffer writeBuffer) {
<span class="fc" id="L72">            this.pixelBuffer = buffer;</span>
<span class="fc" id="L73">            super.compress(buffer.limit(), this.pixelBuffer.get(this.pixelBuffer.position()), new BitBuffer(writeBuffer));</span>
<span class="fc" id="L74">            return true;</span>
        }

        @Override
        public void decompress(ByteBuffer readBuffer, ByteBuffer buffer) {
<span class="fc" id="L79">            this.pixelBuffer = buffer;</span>
<span class="fc" id="L80">            super.decompressBuffer(readBuffer, buffer.limit());</span>
<span class="fc" id="L81">        }</span>

        @Override
        protected int nextPixel() {
<span class="fc" id="L85">            return this.pixelBuffer.get();</span>
        }

        @Override
        protected void nextPixel(int pixel) {
<span class="fc" id="L90">            this.pixelBuffer.put((byte) pixel);</span>
<span class="fc" id="L91">        }</span>
    }

    public static class DoubleRiceCompressor extends DoubleQuantCompressor {

        public DoubleRiceCompressor(RiceQuantizeCompressOption options) {
<span class="fc" id="L97">            super(options, new IntRiceCompressor(options.getRiceCompressOption()));</span>
<span class="fc" id="L98">        }</span>
    }

    public static class FloatRiceCompressor extends FloatQuantCompressor {

        public FloatRiceCompressor(RiceQuantizeCompressOption options) {
<span class="fc" id="L104">            super(options, new IntRiceCompressor(options.getRiceCompressOption()));</span>
<span class="fc" id="L105">        }</span>
    }

    public static class IntRiceCompressor extends RiceCompressor&lt;IntBuffer&gt; {

        private IntBuffer pixelBuffer;

        public IntRiceCompressor(RiceCompressOption option) {
<span class="fc" id="L113">            super(option.setDefaultBytePix(ElementType.INT.size()));</span>
<span class="fc" id="L114">        }</span>

        @Override
        public boolean compress(IntBuffer buffer, ByteBuffer writeBuffer) {
<span class="fc" id="L118">            this.pixelBuffer = buffer;</span>
<span class="fc" id="L119">            super.compress(buffer.limit(), this.pixelBuffer.get(this.pixelBuffer.position()), new BitBuffer(writeBuffer));</span>
<span class="fc" id="L120">            return true;</span>
        }

        @Override
        public void decompress(ByteBuffer readBuffer, IntBuffer buffer) {
<span class="fc" id="L125">            this.pixelBuffer = buffer;</span>
<span class="fc" id="L126">            super.decompressBuffer(readBuffer, buffer.limit());</span>
<span class="fc" id="L127">        }</span>

        @Override
        protected int nextPixel() {
<span class="fc" id="L131">            return this.pixelBuffer.get();</span>
        }

        @Override
        protected void nextPixel(int pixel) {
<span class="fc" id="L136">            this.pixelBuffer.put(pixel);</span>
<span class="fc" id="L137">        }</span>
    }

    public static class ShortRiceCompressor extends RiceCompressor&lt;ShortBuffer&gt; {

        private ShortBuffer pixelBuffer;

        public ShortRiceCompressor(RiceCompressOption option) {
<span class="fc" id="L145">            super(option.setDefaultBytePix(ElementType.SHORT.size()));</span>
<span class="fc" id="L146">        }</span>

        @Override
        public boolean compress(ShortBuffer buffer, ByteBuffer writeBuffer) {
<span class="fc" id="L150">            this.pixelBuffer = buffer;</span>
<span class="fc" id="L151">            super.compress(buffer.limit(), this.pixelBuffer.get(this.pixelBuffer.position()), new BitBuffer(writeBuffer));</span>
<span class="fc" id="L152">            return true;</span>
        }

        @Override
        public void decompress(ByteBuffer readBuffer, ShortBuffer buffer) {
<span class="fc" id="L157">            this.pixelBuffer = buffer;</span>
<span class="fc" id="L158">            super.decompressBuffer(readBuffer, buffer.limit());</span>
<span class="fc" id="L159">        }</span>

        @Override
        protected int nextPixel() {
<span class="fc" id="L163">            return this.pixelBuffer.get();</span>
        }

        @Override
        protected void nextPixel(int pixel) {
<span class="fc" id="L168">            this.pixelBuffer.put((short) pixel);</span>
<span class="fc" id="L169">        }</span>
    }

    /**
     * mask to convert a &quot;unsigned&quot; byte to a long.
     */
    private static final long UNSIGNED_BYTE_MASK = 0xFFL;

    /**
     * mask to convert a &quot;unsigned&quot; short to a long.
     */
    private static final long UNSIGNED_SHORT_MASK = 0xFFFFL;

    /**
     * mask to convert a &quot;unsigned&quot; int to a long.
     */
    private static final long UNSIGNED_INTEGER_MASK = 0xFFFFFFFFL;

    /**
     * logger to log to.
     */
<span class="fc" id="L190">    private static final Logger LOG = Logger.getLogger(RiceCompressor.class.getName());</span>

    private static final int BITS_OF_1_BYTE = 8;

    private static final int BITS_PER_BYTE = 8;

    private static final int BYTE_MASK = 0xff;

    private static final int FS_BITS_FOR_BYTE = 3;

    private static final int FS_BITS_FOR_INT = 5;

    private static final int FS_BITS_FOR_SHORT = 4;

    private static final int FS_MAX_FOR_BYTE = 6;

    private static final int FS_MAX_FOR_INT = 25;

    private static final int FS_MAX_FOR_SHORT = 14;

    /*
     * nonzero_count is lookup table giving number of bits in 8-bit values not
     * including leading zeros used in fits_rdecomp, fits_rdecomp_short and
     * fits_rdecomp_byte.
     * @formatter:off
     */
<span class="fc" id="L216">    private static final int[] NONZERO_COUNT = {</span>
        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
    };
    // @formatter:on

    private final int bBits;

    private final int bitsPerPixel;

    private final int blockSize;

    private final int fsBits;

    private final int fsMax;

<span class="fc" id="L246">    private RiceCompressor(RiceCompressOption option) {</span>
<span class="fc" id="L247">        this.blockSize = option.getBlockSize();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (option.getBytePix() == ElementType.BYTE.size()) {</span>
<span class="fc" id="L249">            this.fsBits = FS_BITS_FOR_BYTE;</span>
<span class="fc" id="L250">            this.fsMax = FS_MAX_FOR_BYTE;</span>
<span class="fc" id="L251">            this.bitsPerPixel = FitsIO.BITS_OF_1_BYTE;</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        } else if (option.getBytePix() == ElementType.SHORT.size()) {</span>
<span class="fc" id="L253">            this.fsBits = FS_BITS_FOR_SHORT;</span>
<span class="fc" id="L254">            this.fsMax = FS_MAX_FOR_SHORT;</span>
<span class="fc" id="L255">            this.bitsPerPixel = FitsIO.BITS_OF_2_BYTES;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        } else if (option.getBytePix() == ElementType.INT.size()) {</span>
<span class="fc" id="L257">            this.fsBits = FS_BITS_FOR_INT;</span>
<span class="fc" id="L258">            this.fsMax = FS_MAX_FOR_INT;</span>
<span class="fc" id="L259">            this.bitsPerPixel = FitsIO.BITS_OF_4_BYTES;</span>
        } else {
<span class="fc" id="L261">            throw new UnsupportedOperationException(&quot;Rice only supports 1/2/4 type per pixel&quot;);</span>
        }
        /*
         * From bsize derive: FSBITS = # bits required to store FS FSMAX =
         * maximum value for FS BBITS = bits/pixel for direct coding
         */
<span class="fc" id="L267">        this.bBits = 1 &lt;&lt; this.fsBits;</span>
<span class="fc" id="L268">    }</span>

    /**
     * &lt;p&gt;
     * undo mapping and differencing Note that some of these operations will
     * overflow the unsigned int arithmetic -- that's OK, it all works out to
     * give the right answers in the output file.
     * &lt;/p&gt;
     * &lt;p&gt;
     * In java this is more complicated because of the missing unsigned
     * integers. trying to simulate the behavior
     * &lt;/p&gt;
     *
     * @param lastpix
     *            the current last pix value
     * @param diff
     *            the difference to &quot;add&quot;
     * @return return the new lastpiy value
     */
    private long undoMappingAndDifferencing(long lastpix, long diff) {
<span class="fc" id="L288">        diff &amp;= UNSIGNED_INTEGER_MASK;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if ((diff &amp; 1) == 0) {</span>
<span class="fc" id="L290">            diff = diff &gt;&gt;&gt; 1;</span>
        } else {
<span class="fc" id="L292">            diff = diff &gt;&gt;&gt; 1 ^ UNSIGNED_INTEGER_MASK;</span>
        }
<span class="fc" id="L294">        lastpix = diff + lastpix &amp; UNSIGNED_INTEGER_MASK;</span>
<span class="fc" id="L295">        nextPixel((int) lastpix);</span>
<span class="fc" id="L296">        return lastpix;</span>
    }

    /**
     * compress the integer tiledImageOperation on a rise compressed byte
     * buffer.
     *
     * @param dataLength
     *            length of the data to compress
     * @param firstPixel
     *            the value of the first pixel
     * @param buffer
     *            the buffer to write to
     */
    protected void compress(final int dataLength, int firstPixel, BitBuffer buffer) {
        /* the first difference will always be zero */
<span class="fc" id="L312">        int lastpix = firstPixel;</span>
        /* write out first int value to the first 4 bytes of the buffer */
<span class="fc" id="L314">        buffer.putInt(firstPixel, this.bitsPerPixel);</span>
<span class="fc" id="L315">        int thisblock = this.blockSize;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        for (int i = 0; i &lt; dataLength; i += this.blockSize) {</span>
            /* last block may be shorter */
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (dataLength - i &lt; this.blockSize) {</span>
<span class="fc" id="L319">                thisblock = dataLength - i;</span>
            }
            /*
             * Compute differences of adjacent pixels and map them to unsigned
             * values. Note that this may overflow the integer variables --
             * that's OK, because we can recover when decompressing. If we were
             * compressing shorts or bytes, would want to do this arithmetic
             * with short/byte working variables (though diff will still be
             * passed as an int.) compute sum of mapped pixel values at same
             * time use double precision for sum to allow 32-bit integer inputs
             */
<span class="fc" id="L330">            long[] diff = new long[this.blockSize];</span>
<span class="fc" id="L331">            double pixelsum = 0.0;</span>
            int nextpix;
            /*
             * tiledImageOperation for differences mapped to non-negative values
             */
<span class="fc bfc" id="L336" title="All 2 branches covered.">            for (int j = 0; j &lt; thisblock; j++) {</span>
<span class="fc" id="L337">                nextpix = nextPixel();</span>
<span class="fc" id="L338">                long pdiff = (nextpix - lastpix);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                diff[j] = (pdiff &lt; 0 ? (pdiff &lt;&lt; 1) ^ UNSIGNED_INTEGER_MASK : pdiff &lt;&lt; 1) &amp; UNSIGNED_INTEGER_MASK;</span>
<span class="fc" id="L340">                pixelsum += diff[j];</span>
<span class="fc" id="L341">                lastpix = nextpix;</span>
            }

            /*
             * compute number of bits to split from sum
             */
<span class="fc" id="L347">            double dpsum = (pixelsum - thisblock / 2d - 1d) / thisblock;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (dpsum &lt; 0) {</span>
<span class="fc" id="L349">                dpsum = 0.0;</span>
            }
<span class="fc" id="L351">            long psum = (long) dpsum &gt;&gt; 1;</span>
            int fs;
<span class="fc bfc" id="L353" title="All 2 branches covered.">            for (fs = 0; psum &gt; 0; fs++) { // NOSONAR</span>
<span class="fc" id="L354">                psum &gt;&gt;= 1;</span>
            }

            /*
             * write the codes fsbits ID bits used to indicate split level
             */
<span class="fc bfc" id="L360" title="All 2 branches covered.">            if (fs &gt;= this.fsMax) {</span>
                /*
                 * Special high entropy case when FS &gt;= fsmax Just write pixel
                 * difference values directly, no Rice coding at all.
                 */
<span class="fc" id="L365">                buffer.putInt(this.fsMax + 1, this.fsBits);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">                for (int j = 0; j &lt; thisblock; j++) {</span>
<span class="fc" id="L367">                    buffer.putLong(diff[j], this.bBits);</span>
                }
<span class="fc bfc" id="L369" title="All 4 branches covered.">            } else if (fs == 0 &amp;&amp; pixelsum == 0) { // NOSONAR</span>
                /*
                 * special low entropy case when FS = 0 and pixelsum=0 (all
                 * pixels in block are zero.) Output a 0 and return
                 */
<span class="fc" id="L374">                buffer.putInt(0, this.fsBits);</span>
            } else {
                /* normal case: not either very high or very low entropy */
<span class="fc" id="L377">                buffer.putInt(fs + 1, this.fsBits);</span>
<span class="fc" id="L378">                int fsmask = (1 &lt;&lt; fs) - 1;</span>
                /*
                 * local copies of bit buffer to improve optimization
                 */
<span class="fc" id="L382">                int bitsToGo = buffer.missingBitsInCurrentByte();</span>
<span class="fc" id="L383">                int bitBuffer = buffer.bitbuffer() &gt;&gt; bitsToGo;</span>
<span class="fc" id="L384">                buffer.movePosition(bitsToGo - BITS_OF_1_BYTE);</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">                for (int j = 0; j &lt; thisblock; j++) {</span>
<span class="fc" id="L386">                    int v = (int) diff[j];</span>
<span class="fc" id="L387">                    int top = v &gt;&gt; fs;</span>
                    /*
                     * top is coded by top zeros + 1
                     */
<span class="fc bfc" id="L391" title="All 2 branches covered.">                    if (bitsToGo &gt;= top + 1) {</span>
<span class="fc" id="L392">                        bitBuffer &lt;&lt;= top + 1;</span>
<span class="fc" id="L393">                        bitBuffer |= 1;</span>
<span class="fc" id="L394">                        bitsToGo -= top + 1;</span>
                    } else {
<span class="fc" id="L396">                        bitBuffer &lt;&lt;= bitsToGo;</span>
<span class="fc" id="L397">                        buffer.putByte((byte) (bitBuffer &amp; BYTE_MASK));</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                        for (top -= bitsToGo; top &gt;= BITS_OF_1_BYTE; top -= BITS_OF_1_BYTE) {</span>
<span class="fc" id="L399">                            buffer.putByte((byte) 0);</span>
                        }
<span class="fc" id="L401">                        bitBuffer = 1;</span>
<span class="fc" id="L402">                        bitsToGo = BITS_OF_1_BYTE - 1 - top;</span>
                    }
                    /*
                     * bottom FS bits are written without coding code is
                     * output_nbits, moved into this routine to reduce overheads
                     * This code potentially breaks if FS&gt;24, so I am limiting
                     * FS to 24 by choice of FSMAX above.
                     */
<span class="fc bfc" id="L410" title="All 2 branches covered.">                    if (fs &gt; 0) {</span>
<span class="fc" id="L411">                        bitBuffer &lt;&lt;= fs;</span>
<span class="fc" id="L412">                        bitBuffer |= v &amp; fsmask;</span>
<span class="fc" id="L413">                        bitsToGo -= fs;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">                        while (bitsToGo &lt;= 0) {</span>
<span class="fc" id="L415">                            buffer.putByte((byte) (bitBuffer &gt;&gt; -bitsToGo &amp; BYTE_MASK));</span>
<span class="fc" id="L416">                            bitsToGo += BITS_OF_1_BYTE;</span>
                        }
                    }
                }
<span class="fc" id="L420">                buffer.putByte((byte) (bitBuffer &amp; BYTE_MASK), BITS_OF_1_BYTE - bitsToGo);</span>
            }
        }
<span class="fc" id="L423">        buffer.close();</span>
<span class="fc" id="L424">    }</span>

    /**
     * decompress the readbuffer and fill the pixelarray.
     *
     * @param readBuffer
     *            input buffer
     * @param nx
     *            the number of pixel to uncompress
     */
    protected void decompressBuffer(final ByteBuffer readBuffer, final int nx) {
        /* first x bytes of input buffer contain the value of the first */
        /* x byte integer value, without any encoding */
<span class="fc" id="L437">        long lastpix = 0L;</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (this.bitsPerPixel == ElementType.BYTE.bitPix()) {</span>
<span class="fc" id="L439">            lastpix = readBuffer.get() &amp; UNSIGNED_BYTE_MASK;</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        } else if (this.bitsPerPixel == ElementType.SHORT.bitPix()) {</span>
<span class="fc" id="L441">            lastpix = readBuffer.getShort() &amp; UNSIGNED_SHORT_MASK;</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        } else if (this.bitsPerPixel == ElementType.INT.bitPix()) {</span>
<span class="fc" id="L443">            lastpix = readBuffer.getInt() &amp; UNSIGNED_INTEGER_MASK;</span>
        }
<span class="fc" id="L445">        long b = readBuffer.get() &amp; BYTE_MASK; /* bit buffer */</span>
<span class="fc" id="L446">        int nbits = BITS_PER_BYTE; /* number of bits remaining in b */</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (int i = 0; i &lt; nx;) {</span>
            /* get the FS value from first fsbits */
<span class="fc" id="L449">            nbits -= this.fsBits;</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            while (nbits &lt; 0) {</span>
<span class="fc" id="L451">                b = b &lt;&lt; BITS_PER_BYTE | readBuffer.get() &amp; BYTE_MASK;</span>
<span class="fc" id="L452">                nbits += BITS_PER_BYTE;</span>
            }
<span class="fc" id="L454">            long fs = (b &gt;&gt;&gt; nbits) - 1L;</span>

<span class="fc" id="L456">            b &amp;= (1 &lt;&lt; nbits) - 1;</span>
            /* loop over the next block */
<span class="fc" id="L458">            int imax = i + this.blockSize;</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            if (imax &gt; nx) {</span>
<span class="fc" id="L460">                imax = nx;</span>
            }
<span class="fc bfc" id="L462" title="All 2 branches covered.">            if (fs &lt; 0) {</span>
                /* low-entropy case, all zero differences */
<span class="fc bfc" id="L464" title="All 2 branches covered.">                for (; i &lt; imax; i++) {</span>
<span class="fc" id="L465">                    nextPixel((int) lastpix);</span>
                }
<span class="fc bfc" id="L467" title="All 2 branches covered.">            } else if (fs == this.fsMax) {</span>
                /* high-entropy case, directly coded pixel values */
<span class="fc bfc" id="L469" title="All 2 branches covered.">                for (; i &lt; imax; i++) {</span>
<span class="fc" id="L470">                    int k = this.bBits - nbits;</span>
<span class="fc" id="L471">                    long diff = b &lt;&lt; k;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                    for (k -= BITS_PER_BYTE; k &gt;= 0; k -= BITS_PER_BYTE) {</span>
<span class="fc" id="L473">                        b = readBuffer.get() &amp; BYTE_MASK;</span>
<span class="fc" id="L474">                        diff |= b &lt;&lt; k;</span>
                    }
<span class="fc bfc" id="L476" title="All 2 branches covered.">                    if (nbits &gt; 0) {</span>
<span class="fc" id="L477">                        b = readBuffer.get() &amp; BYTE_MASK;</span>
<span class="fc" id="L478">                        diff |= b &gt;&gt;&gt; -k;</span>
<span class="fc" id="L479">                        b &amp;= (1 &lt;&lt; nbits) - 1L;</span>
                    } else {
<span class="fc" id="L481">                        b = 0;</span>
                    }
<span class="fc" id="L483">                    lastpix = undoMappingAndDifferencing(lastpix, diff);</span>
                }
            } else {
                /* normal case, Rice coding */
<span class="fc bfc" id="L487" title="All 2 branches covered.">                for (; i &lt; imax; i++) {</span>
                    /* count number of leading zeros */
<span class="fc bfc" id="L489" title="All 2 branches covered.">                    while (b == 0) {</span>
<span class="fc" id="L490">                        nbits += BITS_PER_BYTE;</span>
<span class="fc" id="L491">                        b = readBuffer.get() &amp; BYTE_MASK;</span>
                    }
<span class="fc" id="L493">                    long nzero = nbits - NONZERO_COUNT[(int) (b &amp; BYTE_MASK)];</span>
<span class="fc" id="L494">                    nbits -= nzero + 1;</span>
                    /* flip the leading one-bit */
<span class="fc" id="L496">                    b ^= 1 &lt;&lt; nbits;</span>
                    /* get the FS trailing bits */
<span class="fc" id="L498">                    nbits -= fs;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                    while (nbits &lt; 0) {</span>
<span class="fc" id="L500">                        b = b &lt;&lt; BITS_PER_BYTE | readBuffer.get() &amp; BYTE_MASK;</span>
<span class="fc" id="L501">                        nbits += BITS_PER_BYTE;</span>
                    }
<span class="fc" id="L503">                    long diff = nzero &lt;&lt; fs | b &gt;&gt; nbits;</span>
<span class="fc" id="L504">                    b &amp;= (1 &lt;&lt; nbits) - 1L;</span>

<span class="fc" id="L506">                    lastpix = undoMappingAndDifferencing(lastpix, diff);</span>
                }
            }
<span class="fc" id="L509">        }</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (readBuffer.limit() &gt; readBuffer.position()) {</span>
<span class="fc" id="L511">            LOG.warning(&quot;decompressing left over some extra bytes got: &quot; + readBuffer.limit() + &quot; but needed only &quot; + readBuffer.position());</span>
        }

<span class="fc" id="L514">    }</span>

    protected abstract int nextPixel();

    protected abstract void nextPixel(int pixel);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>